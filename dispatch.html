<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Department Dispatch System (Local Persistence)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        #map { height: 100%; }
        .leaflet-container {
            border-radius: 0.5rem;
        }
        .suggestion-item:hover {
            background-color: #f0f0f0;
        }
        .offline-form input,
        .offline-form button[type="submit"] {
            pointer-events: none;
            opacity: 0.5;
            background-color: #f3f4f6;
        }
        .offline-form button[type="submit"] {
            background-color: #9ca3af;
        }
        /* Style for the selected incident card */
        .incident-selected {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 3px #f87171, 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* ring effect */
            background-color: #fef2f2 !important; /* red-50 for subtle highlight */
        }
        /* Map click cursor */
        .map-click-mode {
            cursor: crosshair !important;
        }
        /* Modal styles */
        #quick-incident-modal {
            transition: opacity 0.3s ease-in-out;
            z-index: 1000;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex flex-col md:flex-row h-screen">
        <!-- Sidebar -->
        <div id="sidebar-container" class="w-full md:w-1/3 bg-white p-4 overflow-y-auto shadow-lg">
            
            <!-- HEADER WITH UNDO BUTTON -->
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-bold text-red-700">Local Dispatch Console</h1>
                <button id="undo-btn" class="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-400 text-gray-800 disabled:text-white font-bold py-1 px-2 rounded transition duration-150 text-sm" disabled>
                    <!-- Back Arrow SVG Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                        <path fill-rule="evenodd" d="M15.312 8.412a1.002 1.002 0 0 1 .634.341c.288.354.341.854.148 1.256l-1.049 2.098a.75.75 0 0 0 1.295.648l1.049-2.098a2.502 2.502 0 0 0-.154-4.814 1 1 0 0 1-.692-.98 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 1.7 8.356a.75.75 0 0 0-.256.452l-.63 1.89c-.19.569.21.992.746.857l2.128-.532a.75.75 0 0 0 .584-.712c0-.398-.242-.71-.564-.812a4.002 4.002 0 0 0-.001-.001 1 1 0 0 1 1.004-.996c.555 0 1 .444 1 1a1 1 0 0 1-.996 1.004c-.001 0-.002 0-.003-.001h.001a2.502 2.502 0 0 0 2.501 2.396 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 3.737 4.08 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 2.825-1.127 1 1 0 0 1 1.414 1.414 6.002 6.002 0 0 1-4.239 1.693 1 1 0 0 1-.96-1.004 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 15.312 8.412Z" clip-rule="evenodd" />
                    </svg>
                    <span>Undo</span>
                </button>
            </div>
            <!-- END HEADER WITH UNDO BUTTON -->

            <!-- Status Indicator -->
            <div id="status-indicator" class="text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700">Online: Address Lookup Active</div>

            <!-- Dispatch Form -->
            <form id="dispatch-form" class="mb-6">
                <div class="mb-4 relative">
                    <label for="address" class="block text-gray-700 text-sm font-bold mb-2">Address</label>
                    <input type="text" id="address" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Enter address... (76... postcodes)" autocomplete="off">
                    
                    <!-- Hidden fields to store Lat/Lon upon suggestion click -->
                    <input type="hidden" id="lat-input" value="">
                    <input type="hidden" id="lon-input" value="">

                    <div id="address-suggestions" class="absolute z-10 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden"></div>
                </div>
                <div class="mb-4">
                    <label for="keyword" class="block text-gray-700 text-sm font-bold mb-2">Alarm Keyword</label>
                    <input type="text" id="keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Tree down, Basement flooded" required>
                </div>

                <!-- Error Message Display -->
                <div id="form-message" class="hidden p-2 mb-3 text-sm rounded bg-red-100 text-red-700 font-medium"></div>

                <button type="submit" id="submit-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline transition duration-150">
                    Create Incident
                </button>
            </form>

            <!-- Map Quick Incident Toggle -->
            <button id="toggle-map-mode-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline transition duration-150 mt-4">
                Toggle Map Creation Mode (OFF)
            </button>
            
            <hr class="my-4">

            <!-- Incident List (Active) -->
            <div>
                <h2 class="text-xl font-bold text-gray-800 mb-3">Active Incidents</h2>
                <div id="incident-list" class="space-y-3">
                    <!-- Active incidents will be dynamically inserted here -->
                </div>
            </div>

            <hr class="my-4">

            <!-- Completed Incidents Section (Collapsible) -->
            <button id="completed-toggle-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-bold py-2 px-4 rounded w-full transition duration-150 flex justify-between items-center">
                Completed Incidents (0) ▼
            </button>
            <div id="completed-incident-list" class="space-y-3 mt-3 hidden">
                <!-- Completed incidents will be dynamically inserted here -->
            </div>

            <p class="text-xs text-gray-500 mt-4 text-center">Data saved locally in this browser. Not synchronized.</p>
        </div>

        <!-- Map -->
        <div class="w-full md:w-2/3 h-64 md:h-full" id="map"></div>
    </div>

    <!-- Quick Incident Modal -->
    <div id="quick-incident-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-sm">
            <h3 class="text-xl font-bold mb-4 text-red-700">Quick Pin Drop</h3>
            <p class="mb-4 text-gray-700">A pin was dropped at the clicked location. Enter the alarm keyword to create the incident.</p>
            
            <form id="quick-incident-form">
                <div class="mb-4">
                    <label for="quick-keyword" class="block text-gray-700 text-sm font-bold mb-2">Alarm Keyword</label>
                    <input type="text" id="quick-keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Car accident, Medical aid" required>
                </div>
                <div class="flex justify-between space-x-2">
                    <button type="button" id="cancel-quick-incident" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded transition duration-150 flex-grow">
                        Cancel
                    </button>
                    <button type="submit" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-150 flex-grow">
                        Create Quick Incident
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // --- COMPATIBILITY FIX: Custom UUID Generator (V4) ---
        function generateUUID() {
            let d = new Date().getTime();
            let d2 = (performance && performance.now && (performance.now() * 1000)) || 0;
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                let r = Math.random() * 16;
                if (d > 0) {
                    r = (d + r) % 16 | 0;
                    d = Math.floor(d / 16);
                } else {
                    r = (d2 + r) % 16 | 0;
                    d2 = Math.floor(d2 / 16);
                }
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        // --- END COMPATIBILITY FIX ---


        // --- Local State and Persistence ---
        const LOCAL_STORAGE_KEY = "localDispatchIncidents_v1";
        const LOCAL_STORAGE_HISTORY_KEY = "localDispatchIncidentHistory_v1"; // New key for history
        
        const incidents = new Map();
        const markers = new Map();
        let selectedIncidentId = null; 
        let statusHistory = []; // Stores { id, oldStatus, newStatus }

        // Map Click Mode State
        let mapClickMode = false;
        let pendingQuickIncident = null; 

        // Completed Section State
        let isCompletedSectionOpen = false;

        // --- UI Elements ---
        const dispatchForm = document.getElementById('dispatch-form');
        const addressInput = document.getElementById('address');
        const keywordInput = document.getElementById('keyword');
        const incidentList = document.getElementById('incident-list'); // Active list
        const completedIncidentList = document.getElementById('completed-incident-list'); // Completed list
        const completedToggleBtn = document.getElementById('completed-toggle-btn');
        const statusIndicator = document.getElementById('status-indicator');
        const submitBtn = document.getElementById('submit-btn');
        const formMessage = document.getElementById('form-message');
        const latInput = document.getElementById('lat-input');
        const lonInput = document.getElementById('lon-input');
        const toggleMapModeBtn = document.getElementById('toggle-map-mode-btn');
        const quickIncidentModal = document.getElementById('quick-incident-modal');
        const quickIncidentForm = document.getElementById('quick-incident-form');
        const quickKeywordInput = document.getElementById('quick-keyword');
        const cancelQuickIncidentBtn = document.getElementById('cancel-quick-incident');
        const sidebarContainer = document.getElementById('sidebar-container');
        const undoBtn = document.getElementById('undo-btn'); // New undo button element
        
        let debounceTimer;
        
        // --- Map Initialization (Leaflet.js) ---
        const map = L.map('map').setView([49.0069, 8.4037], 13); // Centered on Karlsruhe
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        map.on('click', onMapClick);
        
        // --- Utility Functions ---

        function showFormMessage(message, isError = true) {
            formMessage.textContent = message;
            formMessage.classList.remove('hidden');
            if (isError) {
                 formMessage.className = 'p-2 mb-3 text-sm rounded bg-red-100 text-red-700 font-medium';
            } else {
                 formMessage.className = 'p-2 mb-3 text-sm rounded bg-green-100 text-green-700 font-medium';
            }
            setTimeout(() => {
                formMessage.classList.add('hidden');
            }, 7000);
        }

        function formatGermanAddress(address) {
            const parts = [];
            const street = address.road || '';
            const houseNumber = address.house_number || '';
            const postcode = address.postcode || '';
            const city = address.city || address.town || address.village || '';

            if (street) parts.push(`${street} ${houseNumber}`.trim());
            if (postcode && city) parts.push(`${postcode} ${city}`);
            else if (city && !parts.includes(city)) parts.push(city);
            
            const finalAddress = parts.join(', ');
            
            if (!finalAddress && address.display_name) {
                return address.display_name;
            }
            
            return finalAddress;
        }

        async function geocodeAddress(query) {
            if (!query || !navigator.onLine) return null;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=de&addressdetails=1&limit=1`);
                const data = await response.json();

                const bestMatch = data.find(place => 
                    place.address && 
                    place.address.postcode && 
                    place.address.postcode.startsWith('76')
                );
                
                return bestMatch || null;
            } catch (error) {
                console.error("Geocoding API error (Nominatim):", error);
                return null;
            }
        }

        // --- Persistence Logic ---

        function saveIncidents() {
            const incidentsArray = Array.from(incidents.values());
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(incidentsArray));
            
            // Save history stack
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(statusHistory));
            
            console.log("Local state saved (incidents and history).");
        }

        function loadIncidents() {
            const cachedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (cachedData) {
                try {
                    const incidentsArray = JSON.parse(cachedData);
                    incidentsArray.forEach(incident => {
                        if (!incident.id) incident.id = generateUUID(); 
                        incidents.set(incident.id, incident);
                    });
                    console.log(`Loaded ${incidents.size} incidents from local storage.`);
                } catch (e) {
                    console.error("Error loading incidents from local storage:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            }
            
            const cachedHistory = localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY);
            if (cachedHistory) {
                try {
                    statusHistory = JSON.parse(cachedHistory);
                } catch (e) {
                    console.error("Error loading history:", e);
                    localStorage.removeItem(LOCAL_STORAGE_HISTORY_KEY);
                }
            }

            renderAllIncidents();
            updateUndoButtonState();
        }
        
        // --- Undo Logic ---

        function updateUndoButtonState() {
            if (statusHistory.length > 0) {
                undoBtn.disabled = false;
                undoBtn.classList.replace('text-white', 'text-gray-800'); 
            } else {
                undoBtn.disabled = true;
                undoBtn.classList.replace('text-gray-800', 'text-white');
            }
        }

        function undoLastAction() {
            if (statusHistory.length === 0) return;

            const lastAction = statusHistory.pop();
            const incident = incidents.get(lastAction.id);

            if (incident) {
                // Revert status
                incident.status = lastAction.oldStatus;
                incidents.set(incident.id, incident);
                
                selectedIncidentId = null; // Clear selection after undo
                saveIncidents();
                renderAllIncidents();
                
                showFormMessage(`Undid action on incident ${lastAction.id.substring(0, 4)}... Reverted to ${lastAction.oldStatus.toUpperCase()}.`, false);
            } else {
                showFormMessage("Error: Incident for undo action not found. History cleared.", true);
                statusHistory = []; // Clear history if action points to non-existent ID
            }

            updateUndoButtonState();
        }

        undoBtn.addEventListener('click', undoLastAction);
        
        // --- Map Click Mode Logic ---

        function toggleMapMode() {
            mapClickMode = !mapClickMode;
            const mapContainer = map.getContainer();
            if (mapClickMode) {
                mapContainer.classList.add('map-click-mode');
                toggleMapModeBtn.textContent = 'Toggle Map Creation Mode (ON)';
                toggleMapModeBtn.classList.replace('bg-indigo-600', 'bg-red-600');
            } else {
                mapContainer.classList.remove('map-click-mode');
                toggleMapModeBtn.textContent = 'Toggle Map Creation Mode (OFF)';
                toggleMapModeBtn.classList.replace('bg-red-600', 'bg-indigo-600');
            }
        }

        async function onMapClick(e) {
            if (!mapClickMode) {
                // If not in creation mode, clicking the map clears the current selection
                if (selectedIncidentId) {
                    selectedIncidentId = null;
                    renderAllIncidents();
                }
                return;
            }

            const reverseGeocodeResponse = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${e.latlng.lat}&lon=${e.latlng.lng}&zoom=18&addressdetails=1`);
            const data = await reverseGeocodeResponse.json();
            
            let address = "Unknown Location (Map Click)";
            if (data && data.display_name) {
                address = data.display_name;
            }

            pendingQuickIncident = {
                lat: e.latlng.lat,
                lon: e.latlng.lng,
                address: address
            };

            quickIncidentModal.classList.remove('hidden');
            quickKeywordInput.focus();
        }

        quickIncidentForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const keyword = quickKeywordInput.value.trim();

            if (!keyword || !pendingQuickIncident) {
                quickIncidentModal.classList.add('hidden');
                return;
            }

            try {
                const newIncident = {
                    id: generateUUID(),
                    formattedAddress: pendingQuickIncident.address,        
                    keyword: keyword,
                    lat: pendingQuickIncident.lat,
                    lon: pendingQuickIncident.lon,
                    status: 'open',
                    createdAt: new Date().toISOString() 
                };
                
                incidents.set(newIncident.id, newIncident);
                saveIncidents();
                renderAllIncidents(); 

                showFormMessage("Quick incident created successfully!", false);

            } catch (error) {
                console.error("CRITICAL RUNTIME ERROR during quick incident creation:", error);
                showFormMessage(`Critical Error: Quick incident failed: ${error.message}`, true);
            } finally {
                quickIncidentModal.classList.add('hidden');
                quickIncidentForm.reset();
                pendingQuickIncident = null;
                toggleMapMode(); 
            }
        });

        cancelQuickIncidentBtn.addEventListener('click', () => {
            quickIncidentModal.classList.add('hidden');
            quickIncidentForm.reset();
            pendingQuickIncident = null;
            toggleMapMode(); 
        });

        // --- Completed Section Toggle Logic ---

        completedToggleBtn.addEventListener('click', () => {
            isCompletedSectionOpen = !isCompletedSectionOpen;
            if (isCompletedSectionOpen) {
                completedIncidentList.classList.remove('hidden');
            } else {
                completedIncidentList.classList.add('hidden');
            }
            renderAllIncidents(); 
        });


        // --- UI Rendering ---

        function getStatusColor(status) {
            if (status === 'open') return 'red';
            if (status === 'dispatched') return 'blue';
            if (status === 'completed') return 'amber'; 
            return 'grey';
        }

        function createMarkerIcon(color) {
            const hexColor = {
                'red': '#ef4444', 
                'blue': '#3b82f6', 
                'amber': '#f59e0b',
                'grey': '#6b7280'
            }[color];
            const svgIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${hexColor}" width="36px" height="36px">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>`;
            return L.divIcon({
                html: svgIcon,
                className: '',
                iconSize: [36, 36],
                iconAnchor: [18, 36],
                popupAnchor: [0, -36]
            });
        }

        function renderIncidentCard(incident) {
            const isCompleted = incident.status === 'completed';

            const incidentElement = document.createElement('div');
            incidentElement.id = `incident-${incident.id}`;
            
            let statusColorClass = 'bg-gray-100 text-gray-800 border-l-4 border-gray-300';
            let buttonHTML = '';
            
            if (incident.status === 'open') {
                statusColorClass = 'bg-red-100 text-red-800 border-l-4 border-red-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn dispatch-btn bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Dispatch Unit</button>`;
            } else if (incident.status === 'dispatched') {
                statusColorClass = 'bg-blue-100 text-blue-800 border-l-4 border-blue-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn complete-btn bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Mark as Completed</button>`;
            } else if (incident.status === 'completed') {
                statusColorClass = 'bg-amber-100 text-amber-800 opacity-75 border-l-4 border-amber-500';
                // No button for completed incidents (revert done via global Undo button)
                buttonHTML = `<button disabled class="bg-gray-300 text-gray-700 text-sm font-bold py-1 px-3 rounded w-full cursor-not-allowed">Completed</button>`;
            }
            
            let selectionClass = '';
            if (incident.id === selectedIncidentId) {
                selectionClass = 'incident-selected';
                if (!isCompleted) { 
                    setTimeout(() => incidentElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }), 50);
                }
            }


            incidentElement.innerHTML = `
                <p class="font-semibold text-gray-800">${incident.keyword}</p>
                <p class="text-sm text-gray-600">${incident.formattedAddress}</p>
                <div class="mt-2">
                    <span class="status-tag text-xs font-medium mr-2 px-2.5 py-0.5 rounded ${statusColorClass.split(' ').filter(c => !c.startsWith('border-')).join(' ')}">${incident.status.toUpperCase()}</span>
                </div>
                <div class="button-container mt-2 space-y-2">${buttonHTML}</div>
            `;
            incidentElement.className = `p-3 bg-gray-50 border rounded-lg shadow-sm ${statusColorClass} ${selectionClass} ${isCompleted ? 'cursor-default' : 'cursor-pointer'}`;
            return incidentElement;
        }


        function renderAllIncidents() {
            incidentList.innerHTML = '';
            completedIncidentList.innerHTML = '';
            markers.forEach(marker => map.removeLayer(marker));
            markers.clear();
            
            const activeIncidents = [];
            const completedIncidents = [];

            incidents.forEach(incident => {
                if (incident.status === 'completed') {
                    completedIncidents.push(incident);
                } else {
                    activeIncidents.push(incident);
                }
            });

            // 1. Render Active Incidents & Markers
            activeIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                incidentList.appendChild(incidentElement);

                // Attach click listener for zoom/selection on the card itself (only active cards)
                incidentElement.addEventListener('click', (e) => {
                    // Ignore clicks on buttons within the card
                    if (e.target.closest('.update-status-btn') || e.target.closest('.button-container')) {
                        return;
                    }
                    selectedIncidentId = incident.id;
                    renderAllIncidents(); 
                    map.flyTo([incident.lat, incident.lon], 15); // Zoom level 15 for street level view
                });

                // 2. Render Map Marker
                if (incident.lat && incident.lon) {
                    const color = getStatusColor(incident.status);
                    const newIcon = createMarkerIcon(color);
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${incident.status.toUpperCase()}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { icon: newIcon }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    
                    // Marker click listener to select the incident
                    newMarker.on('click', function(e) {
                        selectedIncidentId = incident.id;
                        renderAllIncidents(); 
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });

            // 3. Render Completed Incidents & Markers
            completedIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                completedIncidentList.appendChild(incidentElement);
                
                // Completed markers remain on the map
                if (incident.lat && incident.lon) {
                    const color = getStatusColor(incident.status);
                    const newIcon = createMarkerIcon(color);
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${incident.status.toUpperCase()}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { icon: newIcon }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    newMarker.on('click', function(e) {
                        selectedIncidentId = incident.id;
                        renderAllIncidents(); 
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });

            // 4. Update Completed Section Toggle
            const toggleIcon = isCompletedSectionOpen ? '▲' : '▼';
            completedToggleBtn.innerHTML = `Completed Incidents (${completedIncidents.length}) <span class="text-lg font-mono">${toggleIcon}</span>`;
            
            // 5. Ensure Undo button state is correct after rendering
            updateUndoButtonState();
        }

        // --- General Status Update Listener using Event Delegation ---
        sidebarContainer.addEventListener('click', (e) => {
            if (!e.target.classList.contains('update-status-btn')) return;

            const id = e.target.dataset.id;
            const incident = incidents.get(id);

            if (!incident) return;
            
            let oldStatus = incident.status;
            let newStatus;
            let message = '';

            if (e.target.classList.contains('dispatch-btn')) {
                newStatus = 'dispatched';
                message = 'dispatched.';
            } else if (e.target.classList.contains('complete-btn')) {
                newStatus = 'completed'; 
                message = 'marked complete.';
            } else {
                return; 
            }

            // Record history only if the status is actually changing
            if (oldStatus !== newStatus) {
                statusHistory.push({
                    id: id,
                    oldStatus: oldStatus,
                    newStatus: newStatus
                });
            }
            
            // Apply the new status
            incident.status = newStatus;
            
            incidents.set(id, incident);
            selectedIncidentId = null; 
            saveIncidents();
            renderAllIncidents(); // Re-render handles UI and map marker updates
            showFormMessage(`Incident ${id.substring(0, 4)}... ${message}`, false);
        });


        // --- Network and Address Lookup Management (remains the same) ---
        const suggestionsContainer = document.getElementById('address-suggestions');
        
        function setOnlineStatus(isOnline) {
            if (isOnline) {
                statusIndicator.textContent = 'Online: Address Lookup Active';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700';
                dispatchForm.classList.remove('offline-form');
            } else {
                statusIndicator.textContent = 'Offline: Address Lookup Disabled';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-yellow-100 text-yellow-700';
                dispatchForm.classList.add('offline-form');
            }
        }
        
        window.addEventListener('online', () => setOnlineStatus(true));
        window.addEventListener('offline', () => setOnlineStatus(false));
        setOnlineStatus(navigator.onLine);

        toggleMapModeBtn.addEventListener('click', toggleMapMode);


        addressInput.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            const query = addressInput.value;
            
            latInput.value = '';
            lonInput.value = '';

            if (query.length < 3 || !navigator.onLine) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.add('hidden');
                return;
            }
            
            debounceTimer = setTimeout(async () => {
                const data = await geocodeAddress(query);

                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.remove('hidden');

                if (data) {
                    const formattedAddress = formatGermanAddress(data.address);
                    const suggestionItem = document.createElement('div');
                    suggestionItem.textContent = formattedAddress;
                    suggestionItem.className = 'p-2 cursor-pointer suggestion-item';
                    
                    suggestionItem.addEventListener('click', () => {
                        addressInput.value = formattedAddress;
                        latInput.value = data.lat; 
                        lonInput.value = data.lon;

                        suggestionsContainer.classList.add('hidden');
                        suggestionsContainer.innerHTML = '';
                    });
                    suggestionsContainer.appendChild(suggestionItem);
                } else {
                    suggestionsContainer.innerHTML = '<div class="p-2 text-gray-500">No matching 76... address found.</div>';
                }
            }, 300);
        });
        
        document.addEventListener('click', (e) => {
            if (!suggestionsContainer.contains(e.target) && e.target !== addressInput) {
                suggestionsContainer.classList.add('hidden');
            }
        });


        // --- Final Submission Logic (Reads from Hidden Inputs) ---
        dispatchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const keyword = keywordInput.value.trim();
            const addressText = addressInput.value.trim();
            const finalLat = latInput.value;
            const finalLon = lonInput.value;

            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing...';
            
            if (!keyword || !addressText) {
                showFormMessage("Please enter both an address and an alarm keyword.");
                submitBtn.disabled = false;
                submitBtn.textContent = 'Create Incident';
                return;
            }

            let incidentLat = parseFloat(finalLat);
            let incidentLon = parseFloat(finalLon);
            let finalAddressData = { lat: incidentLat, lon: incidentLon, address: {} }; 
            
            if (!finalLat || !finalLon) {
                if (!navigator.onLine) {
                    showFormMessage("Cannot look up address while offline.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Create Incident';
                    return;
                }
                const fallbackLocation = await geocodeAddress(addressText);
                
                if (!fallbackLocation || !fallbackLocation.lat || !fallbackLocation.lon) {
                    showFormMessage("Could not find map coordinates. Please try clicking the suggestion or ensure the address is complete.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Create Incident';
                    return;
                }
                
                incidentLat = parseFloat(fallbackLocation.lat);
                incidentLon = parseFloat(fallbackLocation.lon);
                finalAddressData.address = fallbackLocation.address;
            }
            
            try {
                const displayAddress = finalAddressData.address.display_name ? formatGermanAddress(finalAddressData.address) : addressText;

                const newIncident = {
                    id: generateUUID(),
                    formattedAddress: displayAddress,        
                    keyword: keyword,
                    lat: incidentLat,
                    lon: incidentLon,
                    status: 'open',
                    createdAt: new Date().toISOString() 
                };
                
                incidents.set(newIncident.id, newIncident);
                saveIncidents();
                renderAllIncidents(); 
                
                dispatchForm.reset();
                latInput.value = '';
                lonInput.value = '';
                suggestionsContainer.classList.add('hidden');
                showFormMessage("Incident created successfully!", false);

            } catch (error) {
                console.error("CRITICAL RUNTIME ERROR during incident creation:", error);
                showFormMessage(`Critical Error: Check your browser console for details: ${error.message}`, true);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Create Incident';
            }
        });
        
        // --- Initialize on Load ---
        window.onload = loadIncidents;

    </script>
</body>
</html>
