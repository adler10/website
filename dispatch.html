<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex">
    <title>Einsatzleitsystem der Feuerwehr (Mit Geo-Einsatzabschnitten und Autocomplete)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        #map { height: 100%; }
        .leaflet-container {
            border-radius: 0.5rem;
        }
        /* Highlight cursor when in drawing mode */
        .map-draw-mode {
            cursor: crosshair !important;
        }
        /* Custom styles for Leaflet Draw markers */
        .leaflet-drawing-icon {
            background-color: #ef4444; /* red-500 */
            border: 2px solid #b91c1c; /* red-700 */
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-top: -6px;
            margin-left: -6px;
            position: absolute;
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.4);
        }
        /* Style for the selected incident card */
        .incident-selected {
            border-color: #ef4444 !important; /* red-500 */
            box-shadow: 0 0 0 3px #f87171, 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* ring effect */
            background-color: #fef2f2 !important; /* red-50 for subtle highlight */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex flex-col md:flex-row h-screen">
        <!-- Sidebar -->
        <div id="sidebar-container" class="w-full md:w-1/3 bg-white p-4 overflow-y-auto shadow-lg">
            
            <!-- HEADER WITH UNDO BUTTON -->
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-bold text-red-700">Lokale Einsatzkonsole</h1>
                <button id="undo-btn" class="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-400 text-gray-800 disabled:text-white font-bold py-1 px-2 rounded transition duration-150 text-sm" disabled>
                    <!-- Back Arrow SVG Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                        <path fill-rule="evenodd" d="M15.312 8.412a1.002 1.002 0 0 1 .634.341c.288.354.341.854.148 1.256l-1.049 2.098a.75.75 0 0 0 1.295.648l1.049-2.098a2.502 2.502 0 0 0-.154-4.814 1 1 0 0 1-.692-.98 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 1.7 8.356a.75.75 0 0 0-.256.452l-.63 1.89c-.19.569.21.992.746.857l2.128-.532a.75.75 0 0 0 .584-.712c0-.398-.242-.71-.564-.812a4.002 4.002 0 0 0-.001-.001 1 1 0 0 1 1.004-.996c.555 0 1 .444 1 1a1 1 0 0 1-.996 1.004c-.001 0-.002 0-.003-.001h.001a2.502 2.502 0 0 0 2.501 2.396 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 3.737 4.08 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 2.825-1.127 1 1 0 0 1 1.414 1.414 6.002 6.002 0 0 1-4.239 1.693 1 1 0 0 1-.96-1.004 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 15.312 8.412Z" clip-rule="evenodd" />
                    </svg>
                    <span>Rückgängig</span>
                </button>
            </div>
            <!-- END HEADER WITH UNDO BUTTON -->

            <!-- Status Indicator -->
            <div id="status-indicator" class="text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700">Online: Adresssuche aktiv</div>
            
            <!-- Einsatzabschnitte Management (COLLAPSIBLE) -->
            <div class="mb-6 p-4 bg-gray-50 rounded-lg shadow-inner">
                <h2 id="section-header" class="text-lg font-bold text-gray-800 mb-3 flex items-center justify-between cursor-pointer">
                    <span>Einsatzabschnitte (EA)</span>
                    <button id="toggle-ea-menu" class="text-gray-500 hover:text-gray-700 transition duration-150">
                        <!-- Down Arrow -->
                        <svg id="toggle-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 transition-transform duration-300">
                            <path fill-rule="evenodd" d="M5.22 8.22a.75.75 0 0 0 1.06 1.06L10 6.56l3.72 3.72a.75.75 0 1 0 1.06-1.06L10 4.44 5.22 8.22Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </h2>
                
                <div id="ea-content-wrapper" class="space-y-4">
                    <form id="section-form" class="space-y-2">
                        <input type="text" id="section-name" class="shadow appearance-none border rounded w-full py-1 px-2 text-gray-700 leading-tight text-sm" placeholder="Name des EA (z.B. Wasserversorgung)" required>
                        <input type="text" id="section-responsible" class="shadow appearance-none border rounded w-full py-1 px-2 text-gray-700 leading-tight text-sm" placeholder="Verantwortlicher (z.B. OBM Meier)" required>
                        <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded w-full text-sm transition duration-150">
                            EA erstellen
                        </button>
                    </form>

                    <div id="section-draw-panel" class="p-2 mb-3 bg-red-100 text-red-700 rounded-lg hidden">
                        <p class="font-bold mb-1">EA-Zeichenmodus aktiv!</p>
                        <p class="text-sm">Klicken Sie Punkte auf der Karte, um die Grenze zu definieren.</p>
                        <div class="flex mt-2 space-x-2">
                            <button id="finish-draw-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded flex-grow text-xs">
                                Zeichnen beenden
                            </button>
                            <button id="cancel-draw-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-2 rounded flex-grow text-xs">
                                Abbrechen
                            </button>
                        </div>
                    </div>

                    <div id="section-list" class="space-y-2 mt-3 text-sm">
                        <!-- Section cards will be dynamically inserted here -->
                    </div>
                    <div id="section-message" class="hidden p-2 mt-2 text-xs rounded bg-red-100 text-red-700 font-medium"></div>
                </div>
            </div>
            <!-- END EA Management -->

            <!-- Dispatch Form -->
            <form id="dispatch-form" class="mb-6 border-t pt-4 border-gray-200">
                <div class="mb-3 relative">
                    <label for="address" class="block text-gray-700 text-sm font-bold mb-1">Adresse</label>
                    <input type="text" id="address" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Adresse eingeben... (76... Postleitzahlen)" autocomplete="off">
                    
                    <input type="hidden" id="lat-input" value="">
                    <input type="hidden" id="lon-input" value="">

                    <div id="address-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden"></div>
                </div>
                <div class="mb-3 relative">
                    <label for="keyword" class="block text-gray-700 text-sm font-bold mb-1">Alarmstichwort</label>
                    <input type="text" id="keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="z.B. Baum umgestürzt, Keller unter Wasser" required autocomplete="off">
                    
                    <!-- Autocomplete Suggestions Container (New) -->
                    <div id="keyword-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden max-h-48 overflow-y-auto"></div>
                </div>
                
                <!-- AUTOMATIC ASSIGNMENT DISPLAY -->
                <div class="mb-4 p-2 bg-gray-100 rounded-md border border-dashed border-gray-300">
                    <p class="text-xs font-bold text-gray-700">Automatische EA-Zuordnung:</p>
                    <p id="auto-section-display" class="text-sm font-semibold text-indigo-700">Wird nach Adresse bestimmt...</p>
                    <input type="hidden" id="final-section-assignment" value="">
                </div>
                <!-- END AUTOMATIC ASSIGNMENT DISPLAY -->

                <!-- Error Message Display -->
                <div id="form-message" class="hidden p-2 mb-3 text-sm rounded bg-red-100 text-red-700 font-medium"></div>

                <button type="submit" id="submit-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline transition duration-150">
                    Einsatz erstellen
                </button>
            </form>

            <hr class="my-4">

            <!-- Incident List (Active) -->
            <div>
                <h2 class="text-xl font-bold text-gray-800 mb-3">Aktive Einsätze</h2>
                <div id="incident-list" class="space-y-3">
                    <!-- Active incidents will be dynamically inserted here -->
                </div>
            </div>

            <hr class="my-4">

            <!-- Completed Incidents Section (Collapsible) -->
            <button id="completed-toggle-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-bold py-2 px-4 rounded w-full transition duration-150 flex justify-between items-center">
                Abgeschlossene Einsätze (0) ▼
            </button>
            <div id="completed-incident-list" class="space-y-3 mt-3 hidden">
                <!-- Completed incidents will be dynamically inserted here -->
            </div>

            <p class="text-xs text-gray-500 mt-4 text-center">Daten werden lokal im Browser gespeichert.</p>
        </div>

        <!-- Map -->
        <div class="w-full md:w-2/3 h-64 md:h-full" id="map"></div>
    </div>

    <script>
        // --- AAO KEYWORDS (Schlagwörter from PDF) ---
        // Extracted keywords from the provided document snippet for the autocomplete feature.
        const AAO_KEYWORDS = [
            "B - Fläche klein (< 10m x 10m)", "B - Gasgeruch im Freien", "B - Kleinfeuer", "B - Müllcontainer / -tonne", "B - PKW / Kleinbus innerorts", "B - Rauch- / Brandgeruch Fahrzeug", "B - Rauch- / Brandgeruch im Freien",
			"B - Unklare Feuer- / Rauchentwicklung im Freien", "B - Zweirad"
        ].sort();
        // --- END AAO KEYWORDS ---
        
        
        // --- COMPATIBILITY FIX: Custom UUID Generator (V4) ---
        function generateUUID() {
            let d = new Date().getTime();
            let d2 = (performance && performance.now && (performance.now() * 1000)) || 0;
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                let r = Math.random() * 16;
                if (d > 0) {
                    r = (d + r) % 16 | 0;
                    d = Math.floor(d / 16);
                } else {
                    r = (d2 + r) % 16 | 0;
                    d2 = Math.floor(d2 / 16);
                }
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        // --- END COMPATIBILITY FIX ---


        // --- Local State and Persistence ---
        const LOCAL_STORAGE_KEY = "localDispatchIncidents_v2"; 
        const LOCAL_STORAGE_SECTIONS_KEY = "localDispatchSections_v2"; 
        const LOCAL_STORAGE_HISTORY_KEY = "localDispatchIncidentHistory_v2"; 
        
        const incidents = new Map();
        const sections = new Map(); 
        const markers = new Map();
        const sectionPolygons = new Map(); // Map to store Leaflet Polygon layers
        
        let selectedIncidentId = null; 
        let statusHistory = []; 
        let isCompletedSectionOpen = false;
        
        // --- Drawing State ---
        let drawingSectionId = null;
        let currentDrawPoints = []; // Array of [lat, lon]
        const currentDrawLayer = new L.LayerGroup();
        const drawingIcon = L.divIcon({ className: 'leaflet-drawing-icon' });
        
        // --- UI Elements ---
        const dispatchForm = document.getElementById('dispatch-form');
        const addressInput = document.getElementById('address');
        const keywordInput = document.getElementById('keyword'); // NEW
        const keywordSuggestionsContainer = document.getElementById('keyword-suggestions'); // NEW
        const finalSectionAssignmentInput = document.getElementById('final-section-assignment'); 
        const autoSectionDisplay = document.getElementById('auto-section-display');
        const incidentList = document.getElementById('incident-list');
        const completedIncidentList = document.getElementById('completed-incident-list');
        const completedToggleBtn = document.getElementById('completed-toggle-btn');
        const statusIndicator = document.getElementById('status-indicator');
        const submitBtn = document.getElementById('submit-btn');
        const formMessage = document.getElementById('form-message');
        const latInput = document.getElementById('lat-input');
        const lonInput = document.getElementById('lon-input');
        const sidebarContainer = document.getElementById('sidebar-container');
        const undoBtn = document.getElementById('undo-btn'); 
        const suggestionsContainer = document.getElementById('address-suggestions'); // For Address Autocomplete
        
        // EA Management UI
        const sectionHeader = document.getElementById('section-header');
        const toggleEAMenuBtn = document.getElementById('toggle-ea-menu');
        const toggleIcon = document.getElementById('toggle-icon');
        const eaContentWrapper = document.getElementById('ea-content-wrapper');
        let isEAMenuOpen = true; 
        
        const sectionForm = document.getElementById('section-form');
        const sectionNameInput = document.getElementById('section-name');
        const sectionResponsibleInput = document.getElementById('section-responsible');
        const sectionListContainer = document.getElementById('section-list');
        const sectionMessage = document.getElementById('section-message');
        const sectionDrawPanel = document.getElementById('section-draw-panel');
        const finishDrawBtn = document.getElementById('finish-draw-btn');
        const cancelDrawBtn = document.getElementById('cancel-draw-btn');
        
        let debounceTimer;
        
        // --- Map Initialization (Leaflet.js) ---
        const map = L.map('map').setView([49.0069, 8.4037], 13); // Centered on Karlsruhe
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        currentDrawLayer.addTo(map);
        
        // --- Map Click Handler ---
        function onMapClick(e) {
            // Only handle deselection if not in drawing mode
            if (!drawingSectionId) {
                selectedIncidentId = null;
                renderAllIncidents();
            }
        }
        
        map.on('click', onMapClick);
        // --- END Map Click Handler ---
        
        // --- Utility Functions ---

        function showMessage(element, message, isError = true) {
            element.textContent = message;
            element.classList.remove('hidden');
            if (isError) {
                 element.className = 'p-2 mb-3 text-sm rounded bg-red-100 text-red-700 font-medium';
            } else {
                 element.className = 'p-2 mb-3 text-sm rounded bg-green-100 text-green-700 font-medium';
            }
            // Clear message after 7 seconds
            setTimeout(() => {
                element.classList.add('hidden');
            }, 7000);
        }

        function showFormMessage(message, isError = true) {
            showMessage(formMessage, message, isError);
        }
        function showSectionMessage(message, isError = true) {
            showMessage(sectionMessage, message, isError);
        }

        function formatGermanAddress(address) {
            const parts = [];
            const street = address.road || '';
            const houseNumber = address.house_number || '';
            const postcode = address.postcode || '';
            const city = address.city || address.town || address.village || '';

            if (street) parts.push(`${street} ${houseNumber}`.trim());
            if (postcode && city) parts.push(`${postcode} ${city}`);
            else if (city && !parts.includes(city)) parts.push(city);
            
            const finalAddress = parts.join(', ');
            
            if (!finalAddress && address.display_name) {
                return address.display_name;
            }
            
            return finalAddress;
        }

        async function geocodeAddress(query) {
            if (!query || !navigator.onLine) return null;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=de&addressdetails=1&limit=1`);
                const data = await response.json();

                // Simple check for Karlsruher postcode area (76)
                const bestMatch = data.find(place => 
                    place.address && 
                    place.address.postcode && 
                    place.address.postcode.startsWith('76')
                );
                
                return bestMatch || null;
            } catch (error) {
                console.error("Geocoding API error (Nominatim):", error);
                return null;
            }
        }
        
        /**
         * Point-in-Polygon (PIP) Ray Casting Algorithm
         * Checks if a point [lat, lon] is inside a polygon (array of [lat, lon] arrays).
         */
        function isPointInPolygon(point, polygon) {
            const x = point[0]; 
            const y = point[1]; 
            let inside = false;

            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];

                let intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            return inside;
        }

        /**
         * Determines which EA (if any) contains the given coordinates.
         * @param {number} lat - Incident latitude.
         * @param {number} lon - Incident longitude.
         * @returns {string | null} The ID of the containing section, or null.
         */
        function findContainingSection(lat, lon) {
            let assignedSectionId = null;
            
            sections.forEach(section => {
                if (section.boundary && section.boundary.length >= 3) {
                    const point = [lat, lon];
                    if (isPointInPolygon(point, section.boundary)) {
                        assignedSectionId = section.id;
                    }
                }
            });
            return assignedSectionId;
        }
        
        // --- Geometric Helper Functions for Intersection Check (unchanged) ---
        
        function orientation(p, q, r) {
            const val = (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);

            if (Math.abs(val) < 1e-9) return 0; 
            return (val > 0) ? 1 : 2; 
        }

        function onSegment(p, q, r) {
            return (q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) &&
                    q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]));
        }

        function segmentsIntersect(p1, q1, p2, q2) {
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);

            // General case: Non-collinear orientations
            if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0 && o1 !== o2 && o3 !== o4) {
                return true;
            }
            
            // Special Cases (Collinearity handling to allow touching/sharing vertices)
            // We specifically IGNORE collinear intersections here to allow touching boundaries.
            return false;
        }
        
        /**
         * Checks if the proposed newBoundary intersects any existing EA boundary.
         */
        function checkExistingEAOverlaps(newBoundary, excludeSectionId) {
            let intersectionFound = false;

            sections.forEach(section => {
                if (section.id === excludeSectionId || section.boundary.length < 3) {
                    return; 
                }
                
                const existingBoundary = section.boundary;
                
                // 1. Check for edge intersections (crossing boundaries)
                for (let i = 0; i < newBoundary.length; i++) {
                    const p1 = newBoundary[i];
                    const q1 = newBoundary[(i + 1) % newBoundary.length]; 
                    for (let j = 0; j < existingBoundary.length; j++) {
                        const p2 = existingBoundary[j];
                        const q2 = existingBoundary[(j + 1) % existingBoundary.length]; 
                        
                        if (segmentsIntersect(p1, q1, p2, q2)) {
                            intersectionFound = true;
                            break;
                        }
                    }
                    if (intersectionFound) break;
                }
                if (intersectionFound) return; 
                
                // 2. Check if a vertex of the new boundary is inside the existing boundary (full overlap)
                if (isPointInPolygon(newBoundary[0], existingBoundary)) {
                    intersectionFound = true;
                    return; 
                }
                
                // 3. Check if a vertex of the existing boundary is inside the new boundary (full overlap)
                if (isPointInPolygon(existingBoundary[0], newBoundary)) {
                    intersectionFound = true;
                    return; 
                }
            });

            return intersectionFound;
        }
        
        /**
         * Iterates over all active incidents and re-runs the EA assignment logic.
         */
        function reEvaluateIncidents() {
            let assignmentsChanged = 0;
            incidents.forEach(incident => {
                if (incident.status !== 'completed') {
                    const newSectionId = findContainingSection(incident.lat, incident.lon);
                    if (incident.sectionId !== newSectionId) {
                        incident.sectionId = newSectionId;
                        assignmentsChanged++;
                    }
                }
            });
            if (assignmentsChanged > 0) {
                console.log(`Re-evaluierung: ${assignmentsChanged} Einsätze neu zugeordnet.`);
            }
        }


        // --- Persistence Logic (unchanged) ---

        function saveState() {
            const incidentsArray = Array.from(incidents.values());
            const sectionsArray = Array.from(sections.values());
            
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(incidentsArray));
            localStorage.setItem(LOCAL_STORAGE_SECTIONS_KEY, JSON.stringify(sectionsArray));
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(statusHistory));
            
            console.log("Lokaler Status gespeichert (Einsätze, Abschnitte, Verlauf).");
        }

        function loadState() {
            // 1. Load Sections
            const cachedSections = localStorage.getItem(LOCAL_STORAGE_SECTIONS_KEY);
            if (cachedSections) {
                try {
                    const sectionsArray = JSON.parse(cachedSections);
                    sectionsArray.forEach(section => {
                        if (!section.id) section.id = generateUUID();
                        if (typeof section.boundary === 'undefined') section.boundary = []; 
                        sections.set(section.id, section);
                    });
                    console.log(`Geladen: ${sections.size} Einsatzabschnitte.`);
                } catch (e) {
                    console.error("Fehler beim Laden der Einsatzabschnitte:", e);
                    localStorage.removeItem(LOCAL_STORAGE_SECTIONS_KEY);
                }
            }
            
            // 2. Load Incidents
            const cachedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (cachedData) {
                try {
                    const incidentsArray = JSON.parse(cachedData);
                    incidentsArray.forEach(incident => {
                        if (!incident.id) incident.id = generateUUID(); 
                        if (typeof incident.notes === 'undefined') incident.notes = '';
                        if (typeof incident.sectionId === 'undefined') incident.sectionId = null; 
                        incidents.set(incident.id, incident);
                    });
                    console.log(`Geladen: ${incidents.size} Einsätze aus dem lokalen Speicher.`);
                } catch (e) {
                    console.error("Fehler beim Laden der Einsätze:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            }
            
            // 3. Load History
            const cachedHistory = localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY);
            if (cachedHistory) {
                try {
                    statusHistory = JSON.parse(cachedHistory);
                } catch (e) {
                    console.error("Fehler beim Laden des Verlaufs:", e);
                    localStorage.removeItem(LOCAL_STORAGE_HISTORY_KEY);
                }
            }

            renderAll();
            updateUndoButtonState();
        }

        // --- Undo Logic (unchanged) ---

        function updateUndoButtonState() {
            undoBtn.disabled = statusHistory.length === 0;
            if (statusHistory.length > 0) {
                undoBtn.classList.replace('disabled:bg-gray-400', 'bg-yellow-500');
                undoBtn.classList.replace('disabled:text-white', 'text-gray-800'); 
            } else {
                undoBtn.classList.replace('bg-yellow-500', 'disabled:bg-gray-400');
                undoBtn.classList.replace('text-gray-800', 'disabled:text-white');
            }
        }

        function undoLastAction() {
            if (statusHistory.length === 0) return;

            const lastAction = statusHistory.pop();
            const incident = incidents.get(lastAction.id);

            if (incident) {
                incident.status = lastAction.oldStatus;
                incident.sectionId = findContainingSection(incident.lat, incident.lon); 
                incidents.set(incident.id, incident);
                
                selectedIncidentId = null; 
                saveState();
                renderAll();
                
                showFormMessage(`Aktion für Einsatz ${lastAction.id.substring(0, 4)}... erfolgreich rückgängig gemacht.`, false);
            } else {
                showFormMessage("Fehler: Einsatz für Rückgängig-Aktion nicht gefunden. Verlauf wurde gelöscht.", true);
                statusHistory = []; 
            }

            updateUndoButtonState();
        }

        undoBtn.addEventListener('click', undoLastAction);
        
        // --- EA Menu Toggle Logic (unchanged) ---
        function toggleEAMenu() {
            isEAMenuOpen = !isEAMenuOpen;
            if (isEAMenuOpen) {
                eaContentWrapper.classList.remove('hidden');
                toggleIcon.style.transform = 'rotate(0deg)'; 
            } else {
                eaContentWrapper.classList.add('hidden');
                toggleIcon.style.transform = 'rotate(-90deg)'; 
            }
        }
        
        sectionHeader.addEventListener('click', toggleEAMenu);
        toggleEAMenuBtn.addEventListener('click', (e) => {
            e.stopPropagation(); 
            toggleEAMenu();
        });


        // --- EA Drawing Logic (unchanged) ---
        
        function setDrawMode(isActive, sectionId = null) {
            drawingSectionId = isActive ? sectionId : null;
            const mapContainer = map.getContainer();
            
            if (isActive) {
                mapContainer.classList.add('map-draw-mode');
                sectionDrawPanel.classList.remove('hidden');
                sectionForm.querySelector('button[type="submit"]').disabled = true;
                currentDrawPoints = sections.get(sectionId)?.boundary ? [...sections.get(sectionId).boundary] : []; 
                currentDrawLayer.clearLayers();
                map.on('click', handleMapDrawClick);
                
                if (currentDrawPoints.length > 0) {
                    currentDrawPoints.forEach(p => {
                        L.marker(p, { icon: drawingIcon, clickable: false }).addTo(currentDrawLayer);
                    });
                    if (currentDrawPoints.length > 1) {
                        L.polyline(currentDrawPoints, { color: '#ef4444', weight: 3, opacity: 0.7 }).addTo(currentDrawLayer);
                    }
                }

            } else {
                mapContainer.classList.remove('map-draw-mode');
                sectionDrawPanel.classList.add('hidden');
                sectionForm.querySelector('button[type="submit"]').disabled = false;
                currentDrawPoints = [];
                currentDrawLayer.clearLayers();
                map.off('click', handleMapDrawClick);
            }
            
            renderSectionManager(); 
        }

        function handleMapDrawClick(e) {
            if (!drawingSectionId) return;
            
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            currentDrawPoints.push([lat, lon]);
            
            // Add point marker
            L.marker([lat, lon], { icon: drawingIcon, clickable: false }).addTo(currentDrawLayer);
            
            // Clear old line and draw new line/polygon outline
            currentDrawLayer.eachLayer(layer => {
                if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                    currentDrawLayer.removeLayer(layer);
                }
            });
            L.polyline(currentDrawPoints, { color: '#ef4444', weight: 3, opacity: 0.7 }).addTo(currentDrawLayer);
            
            const section = sections.get(drawingSectionId);
            showSectionMessage(`Punkt hinzugefügt für EA "${section.name}". ${currentDrawPoints.length} Punkte.`, false);
        }

        finishDrawBtn.addEventListener('click', () => {
            if (currentDrawPoints.length < 3) {
                showSectionMessage("Ein Polygon benötigt mindestens 3 Punkte.", true);
                return;
            }
            
            // --- Intersection Check ---
            if (checkExistingEAOverlaps(currentDrawPoints, drawingSectionId)) {
                showSectionMessage("FEHLER: Die neue Grenze überschneidet oder überlappt einen bestehenden Einsatzabschnitt. Dies ist nicht erlaubt.", true);
                return;
            }
            // --- End Intersection Check ---

            const section = sections.get(drawingSectionId);
            if (section) {
                section.boundary = currentDrawPoints;
                sections.set(drawingSectionId, section);
                saveState();
                
                // NEW: Re-evaluate all active incidents
                reEvaluateIncidents();
                
                showSectionMessage(`Grenze für EA "${section.name}" erfolgreich gespeichert. ${sections.get(drawingSectionId).boundary.length} Punkte.`, false);
            }
            setDrawMode(false);
            renderAll();
        });

        cancelDrawBtn.addEventListener('click', () => {
            const section = sections.get(drawingSectionId);
            showSectionMessage(`Zeichnen für EA "${section.name}" abgebrochen. Die alte Grenze (falls vorhanden) bleibt erhalten.`, true);
            setDrawMode(false);
        });
        
        // --- EA Management Logic (unchanged) ---

        sectionForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = sectionNameInput.value.trim();
            const responsible = sectionResponsibleInput.value.trim();

            if (!name || !responsible) {
                showSectionMessage("Bitte füllen Sie beide Felder aus.", true);
                return;
            }
            
            const newSection = {
                id: generateUUID(),
                name: name,
                responsible: responsible,
                boundary: [] 
            };

            sections.set(newSection.id, newSection);
            saveState();
            renderAll();
            showSectionMessage(`EA "${name}" erfolgreich erstellt. Bitte definieren Sie nun die Grenze auf der Karte.`, false);
            sectionForm.reset();
        });

        function deleteSection(id) {
            if (!confirm("Sind Sie sicher, dass Sie diesen Einsatzabschnitt löschen möchten? Alle zugeordneten Einsätze werden freigegeben.")) return;

            if (drawingSectionId === id) setDrawMode(false);

            sections.delete(id);
            
            // Unassign incidents from this section and re-evaluate against others
            incidents.forEach(incident => {
                if (incident.sectionId === id) {
                    incident.sectionId = null;
                }
            });

            // Re-evaluate all incidents now that the section is gone
            reEvaluateIncidents(); 
            
            saveState();
            renderAll();
            showSectionMessage("EA gelöscht.", false);
        }
        
        // --- UI Rendering (unchanged, but includes new functionality) ---

        function renderSectionManager() {
            sectionListContainer.innerHTML = '';
            
            if (sections.size === 0) {
                sectionListContainer.innerHTML = '<p class="text-xs text-gray-500">Noch keine Einsatzabschnitte erstellt.</p>';
            }
            
            // Clear existing polygons from map
            sectionPolygons.forEach(polygon => map.removeLayer(polygon));
            sectionPolygons.clear();

            sections.forEach(section => {
                const count = Array.from(incidents.values()).filter(i => i.sectionId === section.id && i.status !== 'completed').length;
                const hasBoundary = section.boundary && section.boundary.length >= 3;
                
                // 1. Render Section Polygon on Map
                if (hasBoundary) {
                    const isDrawing = drawingSectionId === section.id;
                    const polygon = L.polygon(section.boundary, {
                        color: isDrawing ? '#ef4444' : '#4f46e5', 
                        fillColor: isDrawing ? '#fef2f2' : '#c7d2fe', 
                        fillOpacity: 0.3,
                        weight: 2
                    }).addTo(map);
                    
                    polygon.bindPopup(`<b>EA: ${section.name}</b><br>Verantwortlich: ${section.responsible}<br>${count} aktive Einsätze`);
                    sectionPolygons.set(section.id, polygon);
                }

                // 2. Render Sidebar Card
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'flex flex-col p-2 bg-white rounded border ' + (hasBoundary ? 'border-indigo-300' : 'border-red-300');
                
                const boundaryStatusText = hasBoundary ? 
                    `<span class="text-xs font-medium text-green-700">✓ Grenze definiert</span>` : 
                    `<span class="text-xs font-medium text-red-700">✕ Grenze fehlt</span>`;

                const drawButtonHTML = hasBoundary ? 
                    `<button data-id="${section.id}" class="draw-section-btn bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-1 px-2 rounded flex-grow text-xs transition duration-150">
                        Grenze bearbeiten
                    </button>` :
                    `<button data-id="${section.id}" class="draw-section-btn bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded flex-grow text-xs transition duration-150">
                        Grenze zeichnen
                    </button>`;


                sectionDiv.innerHTML = `
                    <div class="flex justify-between items-start mb-1">
                        <div>
                            <p class="font-semibold text-indigo-700">${section.name} <span class="text-xs bg-indigo-100 text-indigo-600 px-1 rounded ml-1">${count} Einsätze</span></p>
                            <p class="text-xs text-gray-600">V: <span class="font-medium">${section.responsible}</span></p>
                        </div>
                        <button data-id="${section.id}" class="delete-section-btn text-red-500 hover:text-red-700 p-1 rounded transition duration-150" title="Abschnitt löschen">
                            <!-- Trash Icon SVG -->
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 pointer-events-none">
                                <path fill-rule="evenodd" d="M8.75 1A2.75 2.75 0 0 0 6 3.75v.5H2.75a.75.75 0 0 0 0 1.5h14.5a.75.75 0 0 0 0-1.5H14V3.75A2.75 2.75 0 0 0 11.25 1h-2.5ZM10 6a.75.75 0 0 1 .75.75v8.5a.75.75 0 0 1-1.5 0v-8.5A.75.75 0 0 1 10 6ZM6.75 9.25a.75.75 0 0 0-1.5 0v5.5a.75.75 0 0 0 1.5 0v-5.5ZM13.25 9.25a.75.75 0 0 0-1.5 0v5.5a.75.75 0 0 0 1.5 0v-5.5Z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                    <div class="flex justify-between items-center space-x-2 mt-1 pt-1 border-t border-gray-100">
                        ${boundaryStatusText}
                        ${drawButtonHTML}
                    </div>
                `;
                sectionListContainer.appendChild(sectionDiv);
            });
            
            // Add delegation for buttons
            sectionListContainer.querySelectorAll('.delete-section-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    deleteSection(e.target.dataset.id);
                });
            });

            sectionListContainer.querySelectorAll('.draw-section-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    setDrawMode(true, e.target.dataset.id);
                    map.flyTo(map.getCenter(), 13); 
                });
            });
        }
        
        function getStatusColor(status) {
            if (status === 'open') return 'red';
            if (status === 'dispatched') return 'blue';
            if (status === 'completed') return 'amber'; 
            return 'grey';
        }

        function createMarkerIcon(color) {
            const hexColor = {
                'red': '#ef4444', 
                'blue': '#3b82f6', 
                'amber': '#f59e0b',
                'grey': '#6b7280'
            }[color];
            const svgIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${hexColor}" width="36px" height="36px">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>`;
            return L.divIcon({
                html: svgIcon,
                className: '',
                iconSize: [36, 36],
                iconAnchor: [18, 36],
                popupAnchor: [0, -36]
            });
        }

        function getGermanStatusText(status) {
            if (status === 'open') return 'OFFEN';
            if (status === 'dispatched') return 'ENTSANDT';
            if (status === 'completed') return 'ABGESCHLOSSEN';
            return 'UNBEKANNT';
        }

        function renderIncidentCard(incident) {
            const isCompleted = incident.status === 'completed';
            const currentSection = incident.sectionId ? sections.get(incident.sectionId) : null;

            const incidentElement = document.createElement('div');
            incidentElement.id = `incident-${incident.id}`;
            
            let statusColorClass = 'bg-gray-100 text-gray-800 border-l-4 border-gray-300';
            let buttonHTML = '';
            
            if (incident.status === 'open') {
                statusColorClass = 'bg-red-100 text-red-800 border-l-4 border-red-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn dispatch-btn bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Einheit entsenden</button>`;
            } else if (incident.status === 'dispatched') {
                statusColorClass = 'bg-blue-100 text-blue-800 border-l-4 border-blue-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn complete-btn bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Als abgeschlossen markieren</button>`;
            } else if (incident.status === 'completed') {
                statusColorClass = 'bg-amber-100 text-amber-800 opacity-75 border-l-4 border-amber-500';
                buttonHTML = `<button disabled class="bg-gray-300 text-gray-700 text-sm font-bold py-1 px-3 rounded w-full cursor-not-allowed">Abgeschlossen</button>`;
            }
            
            let selectionClass = '';
            let notesSectionHTML = '';
            let sectionInfoHTML = '';

            // EA Info
            if (currentSection) {
                sectionInfoHTML = `<div class="mt-1 text-xs text-indigo-700 font-medium bg-indigo-100 p-1 rounded flex justify-between items-center">
                    <span>EA: ${currentSection.name} (V: ${currentSection.responsible})</span>
                    <button data-id="${incident.id}" class="unassign-section-btn text-red-500 hover:text-red-700 p-0.5 rounded transition duration-150" title="EA-Zuordnung manuell aufheben">
                        <!-- X-icon -->
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 pointer-events-none">
                            <path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" />
                        </svg>
                    </button>
                </div>`;
            } else if (!isCompleted) {
                 sectionInfoHTML = `<div class="mt-1 text-xs text-gray-600 font-medium bg-gray-200 p-1 rounded">
                    EA: Nicht zugeordnet (Keine Grenze gefunden)
                </div>`;
            }


            if (incident.id === selectedIncidentId) {
                selectionClass = 'incident-selected';
                setTimeout(() => incidentElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' }), 50);

                // Notes Section (Active or Read-only for Completed)
                if (!isCompleted) { 
                    notesSectionHTML = `
                        <div class="mt-4 p-3 bg-white rounded-md border border-gray-300 shadow-inner">
                            <label for="notes-${incident.id}" class="block text-gray-700 text-sm font-bold mb-1">Notizen/Details</label>
                            <textarea id="notes-${incident.id}" class="notes-textarea shadow-sm appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500" rows="3" placeholder="Geben Sie hier wichtige Informationen zum Einsatz ein...">${incident.notes || ''}</textarea>
                            <button data-id="${incident.id}" class="save-notes-btn mt-2 bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-1 px-3 rounded transition duration-150 w-full disabled:bg-indigo-300">
                                Notizen speichern
                            </button>
                        </div>
                    `;
                } else if (incident.notes && incident.notes.trim() !== '') {
                    notesSectionHTML = `
                        <div class="mt-4 p-3 bg-gray-100 rounded-md border border-gray-300">
                            <p class="text-xs font-bold text-gray-600 mb-1">Abgeschlossene Notizen:</p>
                            <p class="text-sm text-gray-800 whitespace-pre-wrap">${incident.notes}</p>
                        </div>
                    `;
                }
            }


            incidentElement.innerHTML = `
                <p class="font-semibold text-gray-800">${incident.keyword}</p>
                <p class="text-sm text-gray-600">${incident.formattedAddress}</p>
                <div class="mt-2">
                    <span class="status-tag text-xs font-medium mr-2 px-2.5 py-0.5 rounded ${statusColorClass.split(' ').filter(c => !c.startsWith('border-')).join(' ')}">${getGermanStatusText(incident.status)}</span>
                </div>
                ${sectionInfoHTML}
                ${notesSectionHTML} 
                <div class="button-container mt-2 space-y-2">${buttonHTML}</div>
            `;
            incidentElement.className = `p-3 bg-gray-50 border rounded-lg shadow-sm ${statusColorClass} ${selectionClass} ${isCompleted ? 'cursor-default' : 'cursor-pointer'}`;
            return incidentElement;
        }


        function renderAllIncidents() {
            incidentList.innerHTML = '';
            completedIncidentList.innerHTML = '';
            markers.forEach(marker => map.removeLayer(marker));
            markers.clear();
            
            const activeIncidents = [];
            const completedIncidents = [];

            incidents.forEach(incident => {
                if (incident.status === 'completed') {
                    completedIncidents.push(incident);
                } else {
                    activeIncidents.push(incident);
                }
            });

            // 1. Render Active Incidents & Markers
            activeIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                incidentList.appendChild(incidentElement);

                // Attach click listener for zoom/selection on the card itself (only active cards)
                incidentElement.addEventListener('click', (e) => {
                    // Ignore clicks on interactive elements
                    if (e.target.closest('.update-status-btn') || e.target.closest('.button-container') || e.target.closest('.notes-textarea') || e.target.closest('.save-notes-btn') || e.target.closest('.unassign-section-btn')) {
                        return;
                    }

                    if (selectedIncidentId === incident.id) {
                        selectedIncidentId = null;
                    } else {
                        selectedIncidentId = incident.id;
                        map.flyTo([incident.lat, incident.lon], 15); 
                    }
                    
                    renderAll(); 
                });

                // 2. Render Map Marker
                if (incident.lat && incident.lon) {
                    const color = getStatusColor(incident.status);
                    const newIcon = createMarkerIcon(color);
                    const germanStatus = getGermanStatusText(incident.status);
                    const sectionName = incident.sectionId ? sections.get(incident.sectionId).name : 'Kein EA';
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${germanStatus}<br>EA: ${sectionName}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { icon: newIcon }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    
                    newMarker.on('click', function(e) {
                        selectedIncidentId = incident.id;
                        renderAll(); 
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });

            // 3. Render Completed Incidents & Markers
            completedIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                completedIncidentList.appendChild(incidentElement);
                
                 incidentElement.addEventListener('click', (e) => {
                    if (e.target.closest('.update-status-btn') || e.target.closest('.button-container')) {
                        return;
                    }

                    if (selectedIncidentId === incident.id) {
                        selectedIncidentId = null;
                    } else {
                        selectedIncidentId = incident.id;
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    }
                    renderAll(); 
                });

                if (incident.lat && incident.lon) {
                    const color = getStatusColor(incident.status);
                    const newIcon = createMarkerIcon(color);
                    const germanStatus = getGermanStatusText(incident.status);
                    const sectionName = incident.sectionId ? sections.get(incident.sectionId).name : 'Kein EA';
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${germanStatus}<br>EA: ${sectionName}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { icon: newIcon }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    newMarker.on('click', function(e) {
                        selectedIncidentId = incident.id;
                        renderAll(); 
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });

            // 4. Update Completed Section Toggle
            const toggleIconText = isCompletedSectionOpen ? '▲' : '▼';
            completedToggleBtn.innerHTML = `Abgeschlossene Einsätze (${completedIncidents.length}) <span class="text-lg font-mono">${toggleIconText}</span>`;
            
            // 5. Ensure Undo button state is correct after rendering
            updateUndoButtonState();
        }

        function renderAll() {
            if (drawingSectionId) {
                renderSectionManager(); 
            } else {
                renderSectionManager();
                renderAllIncidents();
            }
        }

        // --- Notes Saving and EA Changing Logic (unchanged) ---
        sidebarContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('save-notes-btn')) {
                const id = e.target.dataset.id;
                const incident = incidents.get(id);
                const notesTextarea = document.getElementById(`notes-${id}`);

                if (!incident || !notesTextarea) return;

                incident.notes = notesTextarea.value.trim();
                incidents.set(id, incident);
                
                saveState();
                
                const originalText = e.target.textContent;
                e.target.textContent = 'Gespeichert!';
                e.target.disabled = true;

                setTimeout(() => {
                    e.target.textContent = originalText;
                    e.target.disabled = false;
                }, 1500);
                
                selectedIncidentId = id; 
                showFormMessage("Notizen erfolgreich gespeichert.", false);
            } else if (e.target.classList.contains('unassign-section-btn')) {
                const id = e.target.dataset.id;
                const incident = incidents.get(id);
                if (!incident) return;
                
                const oldSectionName = sections.get(incident.sectionId)?.name || 'Unbekannt';
                incident.sectionId = null; 
                incidents.set(id, incident);
                
                saveState();
                renderAll();
                
                showFormMessage(`EA-Zuordnung für Einsatz ${id.substring(0, 4)}... (vormals ${oldSectionName}) manuell aufgehoben.`, false);
            }
        });

        // --- General Status Update Listener (unchanged) ---
        sidebarContainer.addEventListener('click', (e) => {
            if (!e.target.classList.contains('update-status-btn')) return;

            const id = e.target.dataset.id;
            const incident = incidents.get(id);

            if (!incident) return;
            
            let oldStatus = incident.status;
            let newStatus;
            let message = '';

            if (e.target.classList.contains('dispatch-btn')) {
                newStatus = 'dispatched';
                message = 'entsandt.';
            } else if (e.target.classList.contains('complete-btn')) {
                newStatus = 'completed'; 
                message = 'als abgeschlossen markiert.';
            } else {
                return; 
            }

            if (oldStatus !== newStatus) {
                statusHistory.push({
                    id: id,
                    oldStatus: oldStatus,
                    newStatus: newStatus
                });
            }
            
            incident.status = newStatus;
            
            if (newStatus === 'completed') {
                incident.sectionId = null; 
            }
            
            incidents.set(id, incident);
            selectedIncidentId = null; 
            saveState();
            renderAll(); 
            showFormMessage(`Einsatz ${id.substring(0, 4)}... ${message}`, false);
        });


        // --- Network and Address Lookup Management (unchanged) ---
        
        function setOnlineStatus(isOnline) {
            if (isOnline) {
                statusIndicator.textContent = 'Online: Adresssuche aktiv';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700';
                dispatchForm.classList.remove('offline-form');
            } else {
                statusIndicator.textContent = 'Offline: Adresssuche deaktiviert';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-yellow-100 text-yellow-700';
                dispatchForm.classList.add('offline-form');
            }
        }
        
        window.addEventListener('online', () => setOnlineStatus(true));
        window.addEventListener('offline', () => setOnlineStatus(false));
        setOnlineStatus(navigator.onLine);


        function updateAutoAssignment(lat, lon) {
            const sectionId = findContainingSection(lat, lon);
            
            if (sectionId) {
                const section = sections.get(sectionId);
                autoSectionDisplay.textContent = `EA: ${section.name} (V: ${section.responsible})`;
                autoSectionDisplay.classList.remove('text-red-700');
                autoSectionDisplay.classList.add('text-indigo-700');
                finalSectionAssignmentInput.value = sectionId;
            } else {
                autoSectionDisplay.textContent = 'Keinem EA zugeordnet';
                autoSectionDisplay.classList.remove('text-indigo-700');
                autoSectionDisplay.classList.add('text-red-700');
                finalSectionAssignmentInput.value = '';
            }
        }


        addressInput.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            const query = addressInput.value;
            
            latInput.value = '';
            lonInput.value = '';
            finalSectionAssignmentInput.value = '';
            autoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
            autoSectionDisplay.classList.remove('text-red-700');
            autoSectionDisplay.classList.add('text-gray-700');

            if (query.length < 3 || !navigator.onLine) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.add('hidden');
                return;
            }
            
            debounceTimer = setTimeout(async () => {
                const data = await geocodeAddress(query);

                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.remove('hidden');

                if (data) {
                    const formattedAddress = formatGermanAddress(data.address);
                    const suggestionItem = document.createElement('div');
                    suggestionItem.textContent = formattedAddress;
                    suggestionItem.className = 'p-2 cursor-pointer hover:bg-gray-100 transition duration-100 suggestion-item';
                    
                    suggestionItem.addEventListener('click', () => {
                        addressInput.value = formattedAddress;
                        latInput.value = data.lat; 
                        lonInput.value = data.lon;

                        suggestionsContainer.classList.add('hidden');
                        suggestionsContainer.innerHTML = '';
                        
                        const lat = parseFloat(data.lat);
                        const lon = parseFloat(data.lon);
                        updateAutoAssignment(lat, lon);
                    });
                    suggestionsContainer.appendChild(suggestionItem);
                } else {
                    suggestionsContainer.innerHTML = '<div class="p-2 text-gray-500">Keine passende 76... Adresse gefunden.</div>';
                    finalSectionAssignmentInput.value = '';
                    autoSectionDisplay.textContent = 'Keine Geo-Daten gefunden';
                    autoSectionDisplay.classList.remove('text-indigo-700');
                    autoSectionDisplay.classList.add('text-red-700');
                }
            }, 300);
        });
        
        document.addEventListener('click', (e) => {
            if (!suggestionsContainer.contains(e.target) && e.target !== addressInput) {
                suggestionsContainer.classList.add('hidden');
            }
            
            // Also hide keyword suggestions if user clicks elsewhere
            if (!keywordSuggestionsContainer.contains(e.target) && e.target !== keywordInput) {
                keywordSuggestionsContainer.classList.add('hidden');
            }
        });


        // --- KEYWORD AUTOCOMPLETE LOGIC (NEW) ---

        keywordInput.addEventListener('input', () => {
            const query = keywordInput.value.trim().toLowerCase();
            keywordSuggestionsContainer.innerHTML = '';

            if (query.length < 2) {
                keywordSuggestionsContainer.classList.add('hidden');
                return;
            }

            const matches = AAO_KEYWORDS.filter(keyword => 
                keyword.toLowerCase().includes(query)
            ).slice(0, 10); // Limit to 10 suggestions

            if (matches.length > 0) {
                matches.forEach(keyword => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.textContent = keyword;
                    suggestionItem.className = 'p-2 cursor-pointer hover:bg-red-100 transition duration-100 text-sm text-gray-800 border-b border-gray-100 last:border-b-0';
                    
                    suggestionItem.addEventListener('click', () => {
                        keywordInput.value = keyword;
                        keywordSuggestionsContainer.classList.add('hidden');
                        keywordSuggestionsContainer.innerHTML = '';
                        keywordInput.focus(); // Keep focus after selection
                    });
                    keywordSuggestionsContainer.appendChild(suggestionItem);
                });
                keywordSuggestionsContainer.classList.remove('hidden');
            } else {
                keywordSuggestionsContainer.classList.add('hidden');
            }
        });

        // --- Final Submission Logic (unchanged) ---
        dispatchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const keyword = keywordInput.value.trim();
            const addressText = addressInput.value.trim();
            let incidentLat = parseFloat(latInput.value);
            let incidentLon = parseFloat(lonInput.value);
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Verarbeite...';
            
            if (!keyword || !addressText) {
                showFormMessage("Bitte geben Sie sowohl eine Adresse als auch ein Alarmstichwort ein.");
                submitBtn.disabled = false;
                submitBtn.textContent = 'Einsatz erstellen';
                return;
            }
            
            if (isNaN(incidentLat) || isNaN(incidentLon)) {
                if (!navigator.onLine) {
                    showFormMessage("Adresse konnte im Offline-Modus nicht finalisiert werden.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Einsatz erstellen';
                    return;
                }
                const fallbackLocation = await geocodeAddress(addressText);
                
                if (!fallbackLocation || !fallbackLocation.lat || !fallbackLocation.lon) {
                    showFormMessage("Kartenkoordinaten konnten nicht gefunden werden. Bitte klicken Sie auf den Vorschlag.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Einsatz erstellen';
                    return;
                }
                
                incidentLat = parseFloat(fallbackLocation.lat);
                incidentLon = parseFloat(fallbackLocation.lon);
            }
            
            try {
                const finalSectionId = findContainingSection(incidentLat, incidentLon);
                
                const newIncident = {
                    id: generateUUID(),
                    formattedAddress: addressText,        
                    keyword: keyword,
                    lat: incidentLat,
                    lon: incidentLon,
                    status: 'open',
                    notes: '', 
                    sectionId: finalSectionId, 
                    createdAt: new Date().toISOString() 
                };
                
                incidents.set(newIncident.id, newIncident);
                saveState();
                renderAll(); 
                
                dispatchForm.reset();
                latInput.value = '';
                lonInput.value = '';
                suggestionsContainer.classList.add('hidden');
                autoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
                
                showFormMessage("Einsatz erfolgreich erstellt und automatisch zugeordnet.", false);

            } catch (error) {
                console.error("KRITISCHER LAUFZEITFEHLER beim Erstellen des Einsatzes:", error);
                showFormMessage(`Kritischer Fehler: Details in der Browser-Konsole prüfen: ${error.message}`, true);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Einsatz erstellen';
            }
        });
        
        // --- Completed Section Toggle Logic (unchanged) ---
        completedToggleBtn.addEventListener('click', () => {
            isCompletedSectionOpen = !isCompletedSectionOpen;
            if (isCompletedSectionOpen) {
                completedIncidentList.classList.remove('hidden');
            } else {
                completedIncidentList.classList.add('hidden');
            }
            renderAllIncidents(); 
        });

        // --- Initialize on Load (unchanged) ---
        window.onload = () => {
            loadState();
            if (!isEAMenuOpen) {
                eaContentWrapper.classList.add('hidden');
                toggleIcon.style.transform = 'rotate(-90deg)';
            } else {
                 toggleIcon.style.transform = 'rotate(0deg)';
            }
        };

    </script>
</body>
</html>
