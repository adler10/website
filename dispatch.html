<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noindex">
    <title>Fire Department Dispatch System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        #map { height: 100%; }
        .leaflet-container {
            border-radius: 0.5rem;
        }
        .suggestion-item:hover {
            background-color: #f0f0f0;
        }
        /* Styles for offline mode */
        .offline .dispatch-btn,
        .offline .complete-btn {
            pointer-events: none;
            opacity: 0.5;
            background-color: #9ca3af; /* gray-400 */
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex flex-col md:flex-row h-screen">
        <!-- Sidebar -->
        <div class="w-full md:w-1/3 bg-white p-4 overflow-y-auto shadow-lg">
            <h1 class="text-2xl font-bold text-red-700 mb-4">Dispatch System</h1>

            <!-- Dispatch Form -->
            <form id="dispatch-form" class="mb-6">
                <div class="mb-4 relative">
                    <label for="address" class="block text-gray-700 text-sm font-bold mb-2">Address</label>
                    <input type="text" id="address" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Enter address... (76... postcodes)" autocomplete="off">
                    <div id="address-suggestions" class="absolute z-10 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden"></div>
                </div>
                <div class="mb-4">
                    <label for="keyword" class="block text-gray-700 text-sm font-bold mb-2">Alarm Keyword</label>
                    <input type="text" id="keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="e.g., Tree down, Basement flooded">
                </div>
                <button type="submit" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline">
                    Create Incident
                </button>
            </form>

            <!-- Incident List -->
            <div>
                <h2 class="text-xl font-bold text-gray-800 mb-3">Active Incidents</h2>
                <div id="incident-list" class="space-y-3">
                    <!-- Incidents will be dynamically inserted here -->
                </div>
            </div>
        </div>

        <!-- Map -->
        <div class="w-full md:w-2/3 h-64 md:h-full" id="map"></div>
    </div>

    <!-- Offline Overlay -->
    <div id="offline-overlay" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl text-center">
            <h3 class="text-xl font-bold text-yellow-600">Connection Lost</h3>
            <p class="text-gray-700 mt-2">You are offline. Inputs are disabled to protect data.<br>Last known incidents are shown.</p>
        </div>
    </div>

    <script type="module">
        // --- Firebase Initialization ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, doc, updateDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-dispatch-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "your-api-key", authDomain: "your-auth-domain", projectId: "your-project-id" };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        // setLogLevel('debug');

        // --- UI Elements for Offline Mode ---
        const dispatchForm = document.getElementById('dispatch-form');
        const addressInput = document.getElementById('address');
        const keywordInput = document.getElementById('keyword');
        const submitButton = dispatchForm.querySelector('button[type="submit"]');
        const offlineOverlay = document.getElementById('offline-overlay');
        const incidentListContainer = document.getElementById('incident-list');
        const incidentList = document.getElementById('incident-list');

        let userId;
        let incidentsCollection;
        
        const incidents = new Map();
        const markers = new Map();

        // --- Map Initialization (Leaflet.js) ---
        const map = L.map('map').setView([49.0069, 8.4037], 13); // Centered on Karlsruhe
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // --- Cache Management ---
        const CACHE_KEY = `dispatchIncidentsCache_${appId}`;

        function saveIncidentsToCache() {
            // Only save if we're online; don't save an empty map if we load offline
            if (navigator.onLine) {
                localStorage.setItem(CACHE_KEY, JSON.stringify(Array.from(incidents.entries())));
                console.log("Incidents saved to cache.");
            }
        }

        function loadIncidentsFromCache() {
            const cachedData = localStorage.getItem(CACHE_KEY);
            if (cachedData) {
                try {
                    const cachedIncidents = new Map(JSON.parse(cachedData));
                    if (cachedIncidents.size > 0) {
                        console.log(`Loading ${cachedIncidents.size} incidents from cache.`);
                        incidentList.innerHTML = ''; // Clear list to prevent duplicates
                        cachedIncidents.forEach(incident => {
                            incidents.set(incident.id, incident); // Populate in-memory map
                            addIncidentToUI(incident);
                            addMarkerToMap(incident);
                        });
                    }
                } catch (e) {
                    console.error("Error loading cache:", e);
                    localStorage.removeItem(CACHE_KEY); // Clear bad cache
                }
            }
        }

        // --- Offline Mode Management ---
        function setOfflineMode(isOffline) {
            if (isOffline) {
                offlineOverlay.classList.remove('hidden');
                addressInput.disabled = true;
                keywordInput.disabled = true;
                submitButton.disabled = true;
                incidentListContainer.classList.add('offline');
            } else {
                offlineOverlay.classList.add('hidden');
                addressInput.disabled = false;
                keywordInput.disabled = false;
                submitButton.disabled = false;
                incidentListContainer.classList.remove('offline');
            }
        }

        // Initial Load:
        loadIncidentsFromCache(); // Load from cache first
        setOfflineMode(!navigator.onLine); // Set initial online/offline state

        // Add listeners
        window.addEventListener('offline', () => setOfflineMode(true));
        window.addEventListener('online', () => setOfflineMode(false));

        // --- Authentication ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("User authenticated with ID:", userId);
                incidentsCollection = collection(db, `/artifacts/${appId}/public/data/incidents`);
                setupIncidentListener();
            } else {
                console.log("No user signed in.");
            }
        });

        async function authenticateUser() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
            }
        }
        authenticateUser(); // Call authentication


        // --- UI & Map Removal Helpers ---
        function removeIncidentFromUI(id) {
            const el = document.getElementById(`incident-${id}`);
            if (el) el.remove();
            incidents.delete(id);
        }

        function removeMarkerFromMap(id) {
            const marker = markers.get(id);
            if (marker) map.removeLayer(marker);
            markers.delete(id);
        }

        // --- Firestore Real-time Listener ---
        function setupIncidentListener() {
            onSnapshot(incidentsCollection, (snapshot) => {
                let cacheNeedsUpdate = false;
                snapshot.docChanges().forEach((change) => {
                    cacheNeedsUpdate = true;
                    const incidentData = { id: change.doc.id, ...change.doc.data() };
                    
                    if (change.type === "added") {
                        const existingEl = document.getElementById(`incident-${incidentData.id}`);
                        incidents.set(incidentData.id, incidentData);
                        if (existingEl) {
                            updateIncidentInUI(incidentData); // Update cached item
                        } else {
                            addIncidentToUI(incidentData); // Add new item
                        }
                        updateMarkerOnMap(incidentData); // Use update to handle add/move
                    }
                    if (change.type === "modified") {
                        incidents.set(incidentData.id, incidentData);
                        updateIncidentInUI(incidentData);
                        updateMarkerOnMap(incidentData);
                    }
                    if (change.type === "removed") {
                        removeIncidentFromUI(incidentData.id);
                        removeMarkerFromMap(incidentData.id);
                    }
                });

                if (cacheNeedsUpdate) {
                    saveIncidentsToCache();
                }
            });
        }

        // --- UI Management ---
        function addIncidentToUI(incident) {
            const incidentElement = document.createElement('div');
            incidentElement.id = `incident-${incident.id}`;
            incidentElement.className = 'p-3 bg-gray-50 border rounded-lg shadow-sm';
            
            // Determine status color
            let statusColorClass = 'bg-gray-100 text-gray-800';
            if (incident.status === 'open') {
                statusColorClass = 'bg-red-100 text-red-800';
            } else if (incident.status === 'dispatched') {
                statusColorClass = 'bg-blue-100 text-blue-800';
            } else if (incident.status === 'completed') {
                statusColorClass = 'bg-yellow-100 text-yellow-800';
            }

            // Determine button HTML
            let buttonHTML = '';
            if (incident.status === 'open') {
                buttonHTML = `<button data-id="${incident.id}" class="dispatch-btn bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded w-full">Dispatch Unit</button>`;
            } else if (incident.status === 'dispatched') {
                buttonHTML = `<button data-id="${incident.id}" class="complete-btn bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-1 px-3 rounded w-full">Mark as Completed</button>`;
            }

            incidentElement.innerHTML = `
                <p class="font-semibold text-gray-800">${incident.keyword}</p>
                <p class="text-sm text-gray-600">${incident.formattedAddress || incident.address}</p>
                <div class="mt-2">
                    <span class="status-tag text-xs font-medium mr-2 px-2.5 py-0.5 rounded ${statusColorClass}">${incident.status.toUpperCase()}</span>
                </div>
                <div class="button-container mt-2 space-y-2">
                    ${buttonHTML}
                </div>
            `;
            incidentList.prepend(incidentElement);
        }

        function updateIncidentInUI(incident) {
            const el = document.getElementById(`incident-${incident.id}`);
            if (!el) { // If element doesn't exist (e.g., from cache), create it
                addIncidentToUI(incident);
                return;
            }
            
            el.querySelector('.text-sm.text-gray-600').textContent = incident.formattedAddress || incident.address;
            const statusTag = el.querySelector('.status-tag');
            statusTag.textContent = incident.status.toUpperCase();
            
            let statusColorClass = 'bg-gray-100 text-gray-800';
            if (incident.status === 'open') statusColorClass = 'bg-red-100 text-red-800';
            else if (incident.status === 'dispatched') statusColorClass = 'bg-blue-100 text-blue-800';
            else if (incident.status === 'completed') statusColorClass = 'bg-yellow-100 text-yellow-800';
            statusTag.className = `status-tag text-xs font-medium mr-2 px-2.5 py-0.5 rounded ${statusColorClass}`;

            const buttonContainer = el.querySelector('.button-container');
            let buttonHTML = '';
            if (incident.status === 'open') {
                buttonHTML = `<button data-id="${incident.id}" class="dispatch-btn bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded w-full">Dispatch Unit</button>`;
            } else if (incident.status === 'dispatched') {
                buttonHTML = `<button data-id="${incident.id}" class="complete-btn bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-1 px-3 rounded w-full">Mark as Completed</button>`;
            }
            buttonContainer.innerHTML = buttonHTML;
        }

        incidentList.addEventListener('click', async (e) => {
             if (e.target.classList.contains('dispatch-btn')) {
                const id = e.target.dataset.id;
                const incidentRef = doc(db, `/artifacts/${appId}/public/data/incidents`, id);
                try {
                    await updateDoc(incidentRef, { status: 'dispatched' });
                } catch (error) { console.error("Error updating incident status:", error); }
             } else if (e.target.classList.contains('complete-btn')) {
                const id = e.target.dataset.id;
                const incidentRef = doc(db, `/artifacts/${appId}/public/data/incidents`, id);
                try {
                    await updateDoc(incidentRef, { status: 'completed' });
                } catch (error) { console.error("Error updating incident status:", error); }
             }
        });


        // --- Map Management ---
        function getStatusColor(status) {
            if (status === 'open') return 'red';
            if (status === 'dispatched') return 'blue';
            if (status === 'completed') return 'yellow';
            return 'grey';
        }

        function updateMarkerOnMap(incident) {
            if (!incident.lat || !incident.lon) return;

            const marker = markers.get(incident.id);
            const color = getStatusColor(incident.status);
            const newIcon = createMarkerIcon(color);
            const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress || incident.address}`;

            if (marker) {
                 marker.setIcon(newIcon);
                 marker.setPopupContent(popupContent);
            } else {
                const newMarker = L.marker([incident.lat, incident.lon], { icon: newIcon }).addTo(map);
                newMarker.bindPopup(popupContent);
                markers.set(incident.id, newMarker);
            }
        }

        function addMarkerToMap(incident) {
           updateMarkerOnMap(incident); // This function now handles both adding and updating
        }

        function createMarkerIcon(color) {
            const svgIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${color}" width="36px" height="36px">
                  <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>`;
            return L.divIcon({
                html: svgIcon,
                className: '',
                iconSize: [36, 36],
                iconAnchor: [18, 36],
                popupAnchor: [0, -36]
            });
        }


        // --- Address Autocomplete (Nominatim) ---
        const suggestionsContainer = document.getElementById('address-suggestions');
        let selectedLocation = null;
        let debounceTimer;

        function formatGermanAddress(address) {
            const parts = [];
            const street = address.road || '';
            const houseNumber = address.house_number || '';
            const postcode = address.postcode || '';
            const city = address.city || address.town || address.village || '';

            if (street) parts.push(`${street} ${houseNumber}`.trim());
            if (postcode && city) parts.push(`${postcode} ${city}`);
            else if (city && !parts.includes(city)) parts.push(city);
            return parts.join(', ');
        }

        addressInput.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            const query = addressInput.value;
            if (query.length < 3) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.add('hidden');
                return;
            }
            debounceTimer = setTimeout(() => {
                // Removed the viewbox to not over-constrain the search
                fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=de&addressdetails=1`)
                    .then(response => response.json())
                    .then(data => {
                        suggestionsContainer.innerHTML = '';
                        suggestionsContainer.classList.remove('hidden');

                        // Filter results for postcodes starting with "76"
                        const filteredData = data.filter(place =>
                            place.address &&
                            place.address.postcode &&
                            place.address.postcode.startsWith('76')
                        );

                        if (filteredData.length > 0) {
                            filteredData.slice(0, 5).forEach(place => {
                                const formattedAddress = formatGermanAddress(place.address);
                                if (!formattedAddress) return; 

                                const suggestionItem = document.createElement('div');
                                suggestionItem.textContent = formattedAddress;
                                suggestionItem.className = 'p-2 cursor-pointer suggestion-item';
                                suggestionItem.addEventListener('click', () => {
                                    addressInput.value = formattedAddress;
                                    selectedLocation = place; 
                                    suggestionsContainer.classList.add('hidden');
                                    suggestionsContainer.innerHTML = '';
                                });
                                suggestionsContainer.appendChild(suggestionItem);
                            });
                        } else {
                            suggestionsContainer.innerHTML = '<div class="p-2 text-gray-500">No results found in 76... area</div>';
                        }
                    }).catch(err => {
                        console.error("Nominatim API error:", err);
                        suggestionsContainer.innerHTML = '<div class="p-2 text-red-500">Could not fetch addresses</div>';
                        suggestionsContainer.classList.remove('hidden');
                    });
            }, 300);
        });
        
        document.addEventListener('click', (e) => {
            if (!suggestionsContainer.contains(e.target) && e.target !== addressInput) {
                suggestionsContainer.classList.add('hidden');
            }
        });


        // --- Form Submission ---
        dispatchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const keyword = keywordInput.value;

            if (!selectedLocation || !keyword) {
                alert("Please select a valid address and enter a keyword."); // Simple alert for now
                return;
            }
            
            try {
                const cleanAddress = formatGermanAddress(selectedLocation.address);
                const newIncident = {
                    address: selectedLocation.display_name, 
                    formattedAddress: cleanAddress,         
                    keyword: keyword,
                    lat: parseFloat(selectedLocation.lat),
                    lon: parseFloat(selectedLocation.lon),
                    status: 'open',
                    createdAt: new Date()
                };
                
                const docRef = await addDoc(incidentsCollection, newIncident);
                console.log("Incident created with ID: ", docRef.id);
                
                dispatchForm.reset();
                selectedLocation = null;

            } catch (error) {
                console.error("Error adding document: ", error);
            }
        });

    </script>
</body>
</html>

