<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow">
    <title>Einsatzleitsystem der Feuerwehr (Mit Geo-Einsatzabschnitten und Kategorisiertem Autocomplete)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <style>
        #map { height: 100%; }
        .leaflet-container {
            border-radius: 0.5rem;
        }
        /* Highlight cursor when in drawing/pin mode */
        .map-draw-mode, .map-pin-mode { /* ADDED .map-pin-mode */
            cursor: crosshair !important;
        }
        /* Custom styles for Leaflet Draw markers */
        .leaflet-drawing-icon {
            background-color: #fef08a; /* yellow-200 */
            border: 2px solid #eab308; /* yellow-500 */
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-top: -7px;
            margin-left: -7px;
            position: absolute;
            box-shadow: 0 0 0 4px rgba(234, 179, 8, 0.4);
            cursor: move !important; /* Draggable cursor */
        }
        .leaflet-drawing-icon:hover {
            background-color: #eab308; /* yellow-500 */
        }
        /* Style for the selected incident card */
        .incident-selected {
            border-color: #E600E6 !important; /* Magenta color */
            /* FIX: Removed box-shadow (glow) and light background */
            /* box-shadow: 0 0 0 3px rgba(230, 0, 230, 0.4), 0 1px 2px 0 rgba(0, 0, 0, 0.05); */
            /* background-color: #FFB8FF !important; */
            background-color: #f9fafb !important; /* Use a standard gray-50 */
        }
        /* Offline Overlay Z-Index Fix */
        #offline-overlay {
            z-index: 5000 !important; /* Ensure it's on top of Leaflet UI */
        }
        /* Modals Z-Index */
        #end-shift-modal, #ea-management-modal, #incident-creation-modal, #incident-edit-modal { /* ADDED incident edit modal */
            z-index: 6000 !important; /* Ensure it's on top of everything */
        }
        /* Custom label for EA polygons */
        .ea-label {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }

        /* NEW: Toast Notification Styling */
        .toast-notification {
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            opacity: 0;
            transform: translateX(100%);
        }
        .toast-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast-notification.fade-out {
            opacity: 0;
            transform: translateX(100%);
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">
    <div class="flex flex-col md:flex-row h-screen">
        <!-- Sidebar -->
        <div id="sidebar-container" class="w-full md:w-1/3 bg-white p-4 overflow-y-auto shadow-lg">
            
            <!-- HEADER WITH UNDO BUTTON -->
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-bold text-red-700">Lokale Einsatzkonsole</h1>
                <button id="undo-btn" class="flex items-center space-x-1 bg-yellow-500 hover:bg-yellow-600 disabled:bg-gray-400 text-gray-800 disabled:text-white font-bold py-1 px-2 rounded transition duration-150 text-sm" disabled>
                    <!-- Back Arrow SVG Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4">
                        <path fill-rule="evenodd" d="M15.312 8.412a1.002 1.002 0 0 1 .634.341c.288.354.341.854.148 1.256l-1.049 2.098a.75.75 0 0 0 1.295.648l1.049-2.098a2.502 2.502 0 0 0-.154-4.814 1 1 0 0 1-.692-.98 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 1.7 8.356a.75.75 0 0 0-.256.452l-.63 1.89c-.19.569.21.992.746.857l2.128-.532a.75.75 0 0 0 .584-.712c0-.398-.242-.71-.564-.812a4.002 4.002 0 0 0-.001-.001 1 1 0 0 1 1.004-.996c.555 0 1 .444 1 1a1 1 0 0 1-.996 1.004c-.001 0-.002 0-.003-.001h.001a2.502 2.502 0 0 0 2.501 2.396 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 3.737 4.08 1 1 0 0 1 .96.992 4.002 4.002 0 0 0 2.825-1.127 1 1 0 0 1 1.414 1.414 6.002 6.002 0 0 1-4.239 1.693 1 1 0 0 1-.96-1.004 4.002 4.002 0 0 0-4.001-3.655 1 1 0 0 1-.996-1.004c0-.555-.444-1-1-1a1 1 0 0 1-1.004-.996A6.002 6.002 0 0 1 15.312 8.412Z" clip-rule="evenodd" />
                    </svg>
                    <span>Rückgängig</span>
                </button>
            </div>
            <!-- END HEADER WITH UNDO BUTTON -->

            <!-- Status Indicator -->
            <div id="status-indicator" class="text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700">Online: Adresssuche aktiv</div>
            
            <!-- NEW: EA Management Button -->
            <button type="button" id="manage-ea-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded w-full transition duration-150 mb-4">
                Einsatzabschnitte verwalten
            </button>
            <!-- END NEW: EA Management Button -->

            <!-- MOVED: Dispatch Form is now in a modal -->
            
            <!-- NEW: Button to open Incident Creation Modal -->
            <button type="button" id="open-create-incident-modal-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded w-full transition duration-150 mb-4">
                Neuen Einsatz erstellen
            </button>
            <!-- END NEW Button -->


            <!-- DELETED: Form Message Div (now a toast) -->

            <hr class="my-4">

            <!-- Incident List (Active) -->
            <div>
                <!-- NEW: Active Incidents Toggle Button -->
                <button id="active-toggle-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-bold py-2 px-4 rounded w-full transition duration-150 flex justify-between items-center mb-3">
                    Aktive Einsätze (0) ▼
                </button>
                <div id="incident-list" class="space-y-3">
                    <!-- Active incidents will be dynamically inserted here -->
                </div>
            </div>

            <hr class="my-4">

            <!-- Completed Incidents Section (Collapsible) -->
            <button id="completed-toggle-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-bold py-2 px-4 rounded w-full transition duration-150 flex justify-between items-center">
                Abgeschlossene Einsätze (0) ▼
            </button>
            <div id="completed-incident-list" class="space-y-3 mt-3 hidden">
                <!-- Completed incidents will be dynamically inserted here -->
            </div>

            <!-- NEW: End Shift Button -->
            <hr class="my-4">
            <button id="end-shift-btn" class="bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded w-full transition duration-150">
                Schicht beenden & Bericht erstellen
            </button>
            <!-- END NEW: End Shift Button -->


            <p class="text-xs text-gray-500 mt-4 text-center">Daten werden lokal im Browser gespeichert.</p>
        </div>

        <!-- Map -->
        <div class="w-full md:w-2/3 h-64 md:h-full" id="map"></div>
    </div>

    <!-- UPDATED: Offline Overlay with Data Report -->
    <div id="offline-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center p-4 sm:p-8 hidden">
        <!-- Main content box -->
        <div class="bg-white p-6 sm:p-8 rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <!-- Header -->
            <div class="flex-shrink-0 text-center mb-4">
                <svg class="w-12 h-12 sm:w-16 sm:h-16 text-red-600 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z" />
                </svg>
                <h2 class="text-2xl sm:text-3xl font-bold text-gray-900 mb-2">VERBINDUNG VERLOREN</h2>
                <p class="text-base sm:text-lg font-medium text-gray-700 mb-4">SAFE-MODUS AKTIV</p>
                <p class="text-xs sm:text-sm text-gray-600">Alle Eingaben sind gesperrt. Daten zur manuellen Übertragung:</p>
            </div>
            
            <!-- Scrollable Data Report -->
            <div id="offline-data-report" class="flex-grow overflow-y-auto bg-gray-50 p-4 rounded border border-gray-300 space-y-6">
                
                <!-- EA List -->
                <div>
                    <h3 class="text-xl font-bold text-gray-800 mb-2 pb-1 border-b border-gray-300">Einsatzabschnitte (EA)</h3>
                    <div id="offline-ea-list" class="space-y-2">
                        <!-- EAs will be populated here by JS -->
                    </div>
                </div>

                <!-- Incident List -->
                <div>
                    <!-- UPDATED: Title changed -->
                    <h3 class="text-xl font-bold text-gray-800 mb-2 pb-1 border-b border-gray-300">Einsatz-Übersicht</h3>
                    <!-- UPDATED: ID changed -->
                    <div id="offline-incident-report" class="space-y-3">
                        <!-- Incidents will be populated here by JS -->
                    </div>
                </div>

            </div>
            <!-- End Scrollable Data Report -->
        </div>
    </div>
    <!-- END: Offline Overlay -->

    <!-- NEW: Incident Creation Modal -->
    <div id="incident-creation-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center p-4 hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col">
            <!-- Modal Header -->
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-gray-900">Neuen Einsatz erstellen</h2>
                <button id="close-incident-modal-btn" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-100 transition duration-150">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
            <!-- Scrollable Content Area -->
            <div class="overflow-y-auto">
                <!-- Dispatch Form (MOVED) -->
                <form id="dispatch-form" class="border-t pt-4 border-gray-200">
                    
                    <!-- Incident Add Panel (New) -->
                    <!-- This panel is now outside the modal, near the end of <body> -->

                    <!-- Add Incident on Map Button (New) -->
                    <button type="button" id="add-incident-map-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded w-full text-sm transition duration-150 mb-3">
                        Einsatz auf Karte hinzufügen (Pin-Tool)
                    </button>

                    <div class="mb-3 relative">
                        <label for="address" class="block text-gray-700 text-sm font-bold mb-1">Adresse</label>
                        <input type="text" id="address" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Adresse eingeben... (76... Postleitzahlen)" autocomplete="off">
                        
                        <input type="hidden" id="lat-input" value="">
                        <input type="hidden" id="lon-input" value="">

                        <div id="address-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden"></div>
                    </div>
                    <div class="mb-3 relative">
                        <label for="keyword" class="block text-gray-700 text-sm font-bold mb-1">Alarmstichwort</label>
                        <input type="text" id="keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="z.B. Baum umgestürzt, Keller unter Wasser" required autocomplete="off">
                        
                        <!-- Autocomplete Suggestions Container -->
                        <div id="keyword-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden max-h-80 overflow-y-auto"></div>
                    </div>
                    
                    <!-- AUTOMATIC ASSIGNMENT DISPLAY -->
                    <div class="mb-4 p-2 bg-gray-100 rounded-md border border-dashed border-gray-300">
                        <p class="text-xs font-bold text-gray-700">Automatische EA-Zuordnung:</p>
                        <p id="auto-section-display" class="text-sm font-semibold text-indigo-700">Wird nach Adresse bestimmt...</p>
                        <input type="hidden" id="final-section-assignment" value="">
                    </div>
                    <!-- END AUTOMATIC ASSIGNMENT DISPLAY -->

                    <!-- Error Message Display (DELETED, now a toast) -->
                    <!-- <div id="form-message" class="hidden p-2 mb-3 text-sm rounded bg-red-100 text-red-700 font-medium"></div> -->

                    <button type="submit" id="submit-btn" class="bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white font-bold py-2 px-4 rounded w-full focus:outline-none focus:shadow-outline transition duration-150" disabled>
                        Einsatz erstellen
                    </button>
                </form>
                <!-- END Dispatch Form -->
            </div>
        </div>
    </div>
    <!-- END: Incident Creation Modal -->


    <!-- NEW: Incident Edit Modal -->
    <div id="incident-edit-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center p-4 hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col">
            <!-- Modal Header -->
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-gray-900">Einsatz bearbeiten</h2>
                <button id="close-incident-edit-modal-btn" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-100 transition duration-150">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
            <!-- Scrollable Content Area -->
            <div class="overflow-y-auto">
                <form id="incident-edit-form" class="border-t pt-4 border-gray-200 space-y-4">
                    
                    <!-- Add Incident on Map Button (New) -->
                    <button type="button" id="edit-incident-map-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded w-full text-sm transition duration-150">
                        Neue Adresse von Karte wählen (Pin-Tool)
                    </button>

                    <div class="relative">
                        <label for="edit-address" class="block text-gray-700 text-sm font-bold mb-1">Adresse</label>
                        <input type="text" id="edit-address" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="Adresse eingeben... (76... Postleitzahlen)" autocomplete="off">
                        
                        <input type="hidden" id="edit-lat-input" value="">
                        <input type="hidden" id="edit-lon-input" value="">

                        <div id="edit-address-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden"></div>
                    </div>
                    <div class="relative">
                        <label for="edit-keyword" class="block text-gray-700 text-sm font-bold mb-1">Alarmstichwort</label>
                        <input type="text" id="edit-keyword" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" placeholder="z.B. Baum umgestürzt, Keller unter Wasser" required autocomplete="off">
                        
                        <!-- Autocomplete Suggestions Container -->
                        <div id="edit-keyword-suggestions" class="absolute z-20 w-full bg-white border border-gray-300 mt-1 rounded-md shadow-lg hidden max-h-60 overflow-y-auto"></div>
                    </div>

                    <!-- FIX: Replaced Status Dropdown with Buttons -->
                    <div>
                        <label class="block text-gray-700 text-sm font-bold mb-2">Status</label>
                        <input type="hidden" id="edit-status-hidden" value="">
                        <div class="flex w-full rounded-md shadow-sm">
                            <button type="button" id="edit-status-btn-open" data-status="open" class="edit-status-btn flex-1 py-2 px-4 text-sm font-medium rounded-l-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-0 focus:ring-indigo-500">
                                Offen
                            </button>
                            <button type="button" id="edit-status-btn-dispatched" data-status="dispatched" class="edit-status-btn flex-1 py-2 px-4 text-sm font-medium border-t border-b border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-0 focus:ring-indigo-500">
                                Entsandt
                            </button>
                            <button type="button" id="edit-status-btn-completed" data-status="completed" class="edit-status-btn flex-1 py-2 px-4 text-sm font-medium rounded-r-md border border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-0 focus:ring-indigo-500">
                                Abgeschlossen
                            </button>
                        </div>
                    </div>
                    <!-- END FIX -->
                    
                    <!-- AUTOMATIC ASSIGNMENT DISPLAY -->
                    <div class="p-2 bg-gray-100 rounded-md border border-dashed border-gray-300">
                        <p class="text-xs font-bold text-gray-700">Automatische EA-Zuordnung:</p>
                        <p id="edit-auto-section-display" class="text-sm font-semibold text-indigo-700">Wird nach Adresse bestimmt...</p>
                    </div>

                    <hr class="my-2">
                    
                    <!-- Action Buttons -->
                    <!-- FIX: Made buttons equal width (w-1/2) -->
                    <div class="flex justify-between items-center space-x-3">
                        <button type="button" id="delete-incident-btn" class="bg-red-700 hover:bg-red-800 text-white font-bold py-2 px-4 rounded transition duration-150 w-1/2">
                            Einsatz Löschen
                        </button>
                        <button type="submit" id="save-incident-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded w-1/2 transition duration-150">
                            Änderungen speichern
                        </button>
                    </div>
                    <!-- END FIX -->
                </form>
            </div>
        </div>
    </div>
    <!-- END: Incident Edit Modal -->


    <!-- NEW: End Shift Modal -->
    <div id="end-shift-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center p-4 hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-lg">
            <h2 class="text-2xl font-bold text-gray-900 mb-4">Schicht beenden & Bericht erstellen</h2>
            
            <div class="space-y-4">
                <div>
                    <label for="lagezeichner-input" class="block text-sm font-medium text-gray-700 mb-1">Lagezeichner (Name/Namen)</label>
                    <input type="text" id="lagezeichner-input" class="shadow-sm appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="z.B. OBM Meier, HBM Schmidt">
                </div>

                <!-- DELETED: Modal Error Message (now a toast) -->
                <!-- <div id="modal-error-message" class="hidden p-2 text-sm rounded bg-red-100 text-red-700 font-medium"></div> -->

                <!-- Report Summary -->
                <div class="p-4 bg-gray-50 rounded-lg border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">Zusammenfassung</h3>
                    <ul class="space-y-1 text-sm text-gray-700">
                        <li><strong>Einsätze Gesamt:</strong> <span id="report-stats-incidents" class="font-medium">...</span></li>
                        <li><strong>Einsatzabschnitte:</strong> <span id="report-stats-eas" class="font-medium">...</span></li>
                        <li><strong>Berichtsdatum:</strong> <span id="report-stats-date" class="font-medium">...</span></li>
                    </ul>
                </div>

                <!-- Modal Buttons -->
                <div class="flex justify-end space-x-3 mt-6">
                    <button id="cancel-report-btn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded transition duration-150">
                        Abbrechen
                    </button>
                    <button id="create-report-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-150">
                        Bericht erstellen & Herunterladen
                    </button>
                </div>
            </div>
        </div>
    </div>
    <!-- END: End Shift Modal -->

    <!-- NEW: EA Management Modal -->
    <div id="ea-management-modal" class="fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center p-4 hidden">
        <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-2xl font-bold text-gray-900">Einsatzabschnitte verwalten</h2>
                <button id="close-ea-modal-btn" class="text-gray-500 hover:text-gray-700 p-1 rounded-full hover:bg-gray-100 transition duration-150">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            
            <!-- Scrollable Content Area for EA Management -->
            <div id="ea-modal-content" class="overflow-y-auto space-y-4">
                
                <!-- EA Creation Form (Moved from sidebar) -->
                <form id="section-form" class="space-y-3 p-4 bg-gray-50 rounded-lg shadow-inner">
                    <h3 class="text-lg font-bold text-gray-800">Neuen EA erstellen</h3>
                    <div>
                        <label for="section-name" class="block text-sm font-medium text-gray-700">Name des EA</label>
                        <input type="text" id="section-name" class="mt-1 shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight text-sm" placeholder="z.B. Wasserversorgung" required>
                    </div>
                    <div>
                        <label for="section-responsible" class="block text-sm font-medium text-gray-700">Verantwortlicher</label>
                        <input type="text" id="section-responsible" class="mt-1 shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight text-sm" placeholder="z.B. OBM Meier" required>
                    </div>
                    <div>
                        <label for="section-color" class="block text-sm font-medium text-gray-700">Farbe</label>
                        <input type="color" id="section-color" class="mt-1 shadow appearance-none border rounded w-full h-10" value="#4f46e5">
                    </div>
                    <button type="submit" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-3 rounded w-full text-sm transition duration-150">
                        EA erstellen
                    </button>
                </form>

                <!-- EA Drawing Panel (MOVED) -->
                <!-- This panel is now outside the modal, near the end of <body> -->

                <!-- EA List (Moved from sidebar) -->
                <div class="space-y-4">
                     <h3 class="text-lg font-bold text-gray-800">Bestehende EAs</h3>
                    <div id="section-list" class="space-y-3 text-sm">
                        <!-- Section cards will be dynamically inserted here -->
                    </div>
                    <!-- DELETED: Section Message (now a toast) -->
                    <!-- <div id="section-message" class="hidden p-2 mt-2 text-xs rounded bg-red-100 text-red-700 font-medium"></div> -->
                </div>

            </div>
            <!-- End Scrollable Content -->
        </div>
    </div>
    <!-- END: EA Management Modal -->


    <!-- NEW: Global Toast Notification Container -->
    <!-- Z-index 7000 is higher than modals (6000) -->
    <!-- UPDATED: Added space-y-3 to ensure toasts stack correctly -->
    <!-- FIX: Moved toasts to top-8 to avoid conflict with toolboxes -->
    <div id="toast-container" class="fixed top-8 right-8 z-[7000] w-full max-w-xs sm:max-w-md space-y-3">
        <!-- Toasts will be dynamically added here -->
    </div>
    <!-- END: Global Toast Notification Container -->


    <!-- MOVED: EA Drawing Panel -->
    <!-- This panel is now fixed to the bottom-right of the viewport and is only visible when drawingSectionId is active -->
    <!-- Z-index 1000 is fine, it's below modals/toasts -->
    <div id="section-draw-panel" class="fixed bottom-8 right-8 z-[1000] p-4 bg-red-100 text-red-700 rounded-lg hidden shadow-xl w-72">
        <p class="font-bold mb-2">EA-Zeichenmodus aktiv</p>
        <p class="text-sm">Klicken Sie auf die Karte, um Punkte hinzuzufügen.</p>
        <p class="text-sm mt-1">Klicken Sie auf Punkte, um sie zu löschen.</p>
        <div class="flex mt-3 space-x-2">
            <button id="finish-draw-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded flex-grow text-sm">
                Zeichnen beenden
            </button>
            <button id="cancel-draw-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-3 rounded flex-grow text-sm">
                Abbrechen
            </button>
        </div>
    </div>
    <!-- END MOVED: EA Drawing Panel -->

    <!-- NEW: Incident Add Panel (MOVED) -->
    <div id="incident-add-panel" class="fixed bottom-8 right-8 z-[1000] p-4 bg-blue-100 text-blue-700 rounded-lg hidden shadow-xl w-72">
        <p class="font-bold mb-1">Einsatz-Hinzufügen-Modus</p>
        <p class="text-sm">Klicken Sie auf die Karte, um die Adresse zu füllen.</p>
        <div class="flex mt-2 space-x-2">
            <button type="button" id="cancel-add-incident-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-2 rounded w-full text-xs">
                Abbrechen
            </button>
        </div>
    </div>
    <!-- END NEW: Incident Add Panel -->
    
    <!-- NEW: Incident Edit Panel (for map pin) -->
    <div id="incident-edit-panel" class="fixed bottom-8 right-8 z-[1000] p-4 bg-yellow-100 text-yellow-800 rounded-lg hidden shadow-xl w-72">
        <p class="font-bold mb-1">Einsatz-Bearbeiten-Modus</p>
        <p class="text-sm">Klicken Sie auf die Karte, um die Adresse zu ändern.</p>
        <div class="flex mt-2 space-x-2">
            <button type="button" id="cancel-edit-incident-btn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-1 px-2 rounded w-full text-xs">
                Abbrechen
            </button>
        </div>
    </div>
    <!-- END NEW: Incident Edit Panel -->


    <script>
        // --- AAO KEYWORDS ---
        const AAO_KEYWORD_CATEGORIES = {
            "B 1": ["B - Fläche klein (< 10m x 10m)", "B - Gasgeruch im Freien", "B - Kleinfeuer", "B - Müllcontainer / -tonne", "B - PKW / Kleinbus innerorts", "B - Rauch- / Brandgeruch Fahrzeug", "B - Rauch- / Brandgeruch im Freien", "B - Unklare Feuer- / Rauchentwicklung im Freien", "B - Zweirad"],
            "B 2": ["B - Alarmstufenerhöhung auf B 2", "B - Bus", "B - Campingplatz", "B - Explosion im Freien", "B - Fahrzeug sonstiges", "B - Garage / Carport / Gartenhaus", "B - Gasaustritt im Freien klein", "B - Lagerplatz klein", "B - Land- / Forst- / Baumaschine", "B - LKW / Kleintransporter", "B - Maschine", "B - mehrere PKW / Kleinbusse", "B - Person im Freien", "B - PKW / Kleinbus außerorts", "B - Spielplatz", "B - Wald klein (< 10m x 10m)", "B - Wohnmobil / Wohnanhänger"],
            "B 3": ["B - Alarmstufenerhöhung auf B 3", "B - Baustelle", "B - Bordell / Laufhaus", "B - Büro- / Bankgebäude", "B - Bus im / am Gebäude", "B - Dehnfuge", "B - Explosion Kleinobjekt im / am Gebäude", "B - Garage / Carport / Gartenhaus im / am Gebäude", "B - Gasgeruch im / am Gebäude", "B - Gaststätte / Restaurant", "B - Gewässer sonstiges", "B - Hafenanlage / Terminal / Schiffsanlegestelle", "B - Hallenbad / Freibad / Pool", "B - Industrieanlage / -betrieg - Sonstige", "B - Kamin / Heizung / Ofen", "B - Kanalisation", "B - Keller", "B - Kleinfeuer im / am Gebäude", "B - Lagerhalle / Container klein", "B - Lagerplatz groß", "B - Land- / Forst- / Baumaschine im / am Gebäude", "B - LKW / Kleintransporter im / am Gebäude", "B - mehrer PKW / Kleinbusse im / am Gebäude", "B - Müllcontainer / -tonne im / am Gebäude", "B - Öffentliches Gebäude / Objekt geschlossen", "B - Öffentliches Objekt / Gebäude sontiges", "B - Person droht sich zu verbrennen", "B - Person im Gebäude", "B - PKW / Kleinbus im / am Gebäude", "B - privates Gebäude sonstiges", "B - Rauch- / Brandgeruch im Gebäude", "B - Scheune / Stall", "B - Schleuse", "B - Terrasse / Balkon", "B - Unklare Feuer- Rauchentwicklung im / am Gebäude", "B - Volksfest / Bierzelt", "B - Werkstatt", "B - Wohn- / Baucontainer", "B -  Wohnmobiel / Wohnanhänger im / am Gebäude", "B - Wohnung", "B - Zimmer", "B - Zweirad im / am Gebäude"],
			"B 4": ["B - Alarmstufenerhöhung auf B 4", "B - Apotheke / Labor / Arztpraxis", "B - Asylheim / Wohnheim", "B - Bahnhof / Flughafen", "B - Brandausweitung", "B - Dachstuhl / Dachboden", "B - Diskothek / Spielhalle", "B - Freizeit- / Vergnügungspark", "B - Hotel / Jugendherberge", "B - Industrieanlage", "B - Kaserne / Militärische Einrichtung", "B - Kaufhaus / Ladengeschäft", "B - Kindergarten / Schule / Universität", "B - Kino / Theater / Oper", "B - Kirche / Glaubensstätte", "B - Lagerhalle / Container groß", "B - Menschenleben konkret in Gefahr", "B - Museum / Galerie", "B - Sportstation / Sporthalle", "B - Versammlungsstätte"],
			"B 5": ["B - Alarmstufenerhöhung auf B 5", "B - Alten- / Pflegeheim / Krankenhaus", "B - Gefängnis / Haftanstalt / Polizei", "B - Heizkraftwerk", "B - Hochhaus", "B - Parkhaus / Tiefgarage", "B - Sägewerk"],
			"B 6": ["B - Alarmstufenerhöhung auf B 6"],
			"B - Atom": ["B - Fahrzeug - Atom", "B - Industrieanlage / -betrieb - Atom", "B - Luftfahrzeug - Atom", "B - Öffentliches Gebäude / Objekt - Atom", "B - Schienenfahrzeug - Atom", "B - Wasserfahrzeug - Atom", "B - Kernkraftwerk"],
			"B - Bio": ["B - Bio"],
			"B - BMA": ["B - Auslösung BMA", "B - Auslösung Löschanlage","B - Private BMA", "B - Privater Rauchmelder", "B - Private Gaswarnanlage"],
			"B - Boot": ["B - Motorboot / Sportboot", "B - Rauch- / Brandgeruch Wasserfahrzeug"],
			"B - Chemie": [" B - Fahrzeug - Chemie", "B - Luftfahrzeug - Chemie", "B - Schienenfahrzeug - Chemie", "B - Industrieanlage / -betrieb - Chemie", "B - Öffentliches Gebäude / Objekt - Chemie", "B - Wasserfahrzeug - Chemie"],
			"B - Elektroanlage": ["B - Elektrizitätswerk / Trafohaus", "B - Photovoltaik / Solaranlage", "B - Strommast / Leitung"],
			"B - Explosion": ["B - Explosion Fahrzeug", "B - Explosionim / am Gebäude"],
			"B - Flüssigkeit/Gas": ["B - Biogasanlage", "B - Gasaustritt im / am Gebäude", "B - Gasaustritt im Freien groß", "B - Gasflasche", "B - Gastank / Gaslager", "B - Pipeline", "B - Raffinerie / Ölförderanlage", "B - Tanklaster", "B - Tankstelle / Tanklager"],
			"B - Metall": ["B - Metall"],
			"B - Schienentunnel": ["B - Bahnhof / Haltestelle im Untergrund", "B - Schienentunnel / Unterführung"],
			"B - Schiff": ["B - Explosion Wasserfahrzeug", "B - Fahrgastschiff / Hafenfähre", "B - Luftfahrzeug im Wasser", "B - Transportschiff", "B - Wasserfahrzeug sonstiges"],
			"B - Straßentunnel": ["B - Tunnel / Unterführung"],
			"B - Wald": ["B - Fläche groß (> 10m x 10m)", "B - Wald groß (> 10m x 10m)"],
			"B - Zug": ["B - Explosion Schienenfahrzeug", "B - Güterzug / Tankzug", "B - S-Bahn / Personenzug", "B - Schienenfahrzeug sonstiges", "B - Straßenbahn", "B - U-Bahn"],
			"S - Erkundung": ["S - Bomben- / Kampfmittelfund", "S - Nachschau", "TH - Leichenbergung", "TH - Person vermisst / Personensuche"],
			"S - First Responder": ["S - First Responder"],
            "S - Sonstiges": ["S - Ausfall Notruf / Alarmierung", "S - Bedrohungslage", "S - Bereitstellungsraum besetzen", "S - Bombendrohung", "S - Drohendes Attentat", "S - Einsatzalarm überörtlich (ca. 12h)", "S - Einsatzalarm überregional (ca. 24h)", "S - Einsatzbereitschaft herstellen", "S - Führungshaus besetzen", "S - Große Polizeilage (Amok / Terror)", "S - Grundschutz sicherstellen", "S - Maßnahmenstufe 1", "S - Maßnahmenstufe 2", "S - Maßnahmenstufe 3", "S - Stabseinsatz", "S - Vorabinformation / Einsatzanfrage", "S - Voralarm überörtlich (ca. 12h)", "S - Voralarm überregional (ca. 24h)", "S - Wachbesetzung", "S - Überlandhilfe Feuerwehr (außerhalb SK & LK KA)"],
			"TH 1": ["TH - Ast / Baum droht zu fallen", "TH - Ast / Baum entfernen", "TH - Fahrbahn reinigen / aufräumen", "TH - Insekten (Bienen / Hornissen / Hummeln / Wespen)", "TH - Sicherungsarbeiten", "TH - Sonstige Hilfeleistung", "TH - Tierrettung klein", "TH - Tür / Fenster verschließen", "TH - Unfallstelle absichern / ausleuchten", "TH - Verkehrszeichen entfernen", "TH - Wasserschaden"],
			"TH 2": ["TH - Fahrzeug Sicherung / Bergung klein", "TH - Kleineinklemmung", "TH - Person eingeschlossen", "TH - Person eingeschlossen - Aufzug", "TH - Person eingeschlossen - Aufzug + NA", "TH - Person eingeschlossen - Fahrzeug", "TH - Person eingeschlossen - Fahrzeug + NA", "TH - Strom- / Elektrounfall klein", "TH - Unterstützung Rettungsdienst", "TH - Verkehrsunfall (RD - VU mit SoSi)", "TH - Verkehrsunfall ( RD - VU Stufe 1", "TH - Verkehrsunfall (RD - VU Stufe 2)", "TH - Verkehrsunfall (RD - VU Stufe 3)", "TH - Verkehrsunfall (RD - VU Stufe 4)", "TH - VU eCall (Situation unklar)"],
			"TH 3": ["TH - Notfalltüröffnung", "TH - Notfalltüröffnung + NA", "TH - Türöffnung"],
			"TH 4": ["B - Fahrzeug - Menschenleben konkret in Gefahr", "TH - Fahrzeug Sicherung / Bergung groß", "TH - Person eingeklemmt", "TH - Person eingeklemmt - Ast / Baum", "TH - Person eingeklemmt - PKW / Kleinbus", "TH - Person eingeklemmt - Tor / Gerüst / Gestänge", "TH - Person gepfählt", "TH - Strom- / Elektrounfall groß", "TH - Tierrettung groß", "TH - Verkehrsunfall (RD - VU Stufe 5)", "TH - Verkehrsunfall ( RD - VU Stufe 6)", "TH - VU PKW - Person eingeklemmt"],
			"TH 5": ["TH - Baukran droht umzustürzen", "TH - Fahrzeug in Menschenmenge", "TH - Person eingeklemmt - Gebäude", "TH - TH - Person eingeklemmt - Kraftfahrzeug / Maschine", "TH - Person eingeklemmt - LKW / Kleintransporter", "TH - Person eingeklemmt - Maschine / Gerät", "TH - VU LKW - Person eingeklemmt", "TH - TH VU PKW - Personen eingeklemmt (2 bis 5)"],
			"TH 6": ["TH - VU Bus - Person eingeklemmt", "TH - VU LKW - Person eingeklemmt", "TH - VU Massenkarambolage", "TH - VU PKW - Personen eingeklemmt (mehr als 5)"],
			"TH 7": ["B - Gebäude eingestürzt", "TH - Baukran umgestürzt", "TH - Einsturz Gerüst / Gebäude / Verkehrsweg", "TH - Gebäude / Fahrzeug verschüttet", "TH - Person verschüttet"],
			"TH - Beleuchtung": ["TH - Einsatzstelle ausleuchten", "TH - Hubschrauberlandung ausleuchten"],
			"TH - Höhenrettung": ["B - Windkraftwerk / -rad", "TH - Höhlen / Grubenrettung", "TH - Person auf Windkraftanlage", "TH - Person droht zu springen / abzustürzen über 23m", "TH - Person im Seil über 23m", "TH - SRHT über 23m"],
			"TH - Person im Rhein": ["TH - Person im Rhein"],
			"TH - Person im Wasser": ["TH - Eisrettung", "TH - Ertrinkungsunfall / Person im Wasser", "TH - Tauchunfall", "TH - VU Fahrzeug im Wasser (Person in Gefahr)", "TH - Wassersportler / -fahrzeug in Not"],
			"TH - Rettungskorb schwer": ["TH - Unterstützung Rettungsdienst mit Drehleiter (über 130kg)"],
			"TH - Schiene 1": ["TH - Person unter güterzug / Tankzug", "TH - Person unter S-Bahn / Personenzug", "TH - Person unter sonstigem Schienenfahrzeug", "TH - Person unter Straßenbahn", "TH - Person unter U-Bahn", "TH - Sicherung / Bergung Schienenfahrzeug"],
			"TH - Schiene 2": ["TH - Person eingeklemmt - Schienenfahrzeug", "TH - VU Güterzug / Tankzug", "TH - VU S-Bahn / Personenzug", "TH - VU Schienenfahrzeug sonstiges", "TH - VU Straßenbahn", "TH - VU U-Bahn"],
			"TH - Schlüsseldienst": ["TH - Türöffnung (Amtshilfe)"],
			"TH U - Atom": ["TH U - Austretender Gefahrstoff - Atom", "TH U - Fahrzeug - Atom", "TH U - Luftfahrzeug - Atom", "TH U - Schienenfahrzeug - Atom", "TH U - Wasserfahrzeug - Atom"],
			"TH U - Auslaufen von Kraftstoffen groß": ["TH U - Austretende Betriebsstoffe Gewässer", "TH U - Austretende Betriebsstoffe groß", "TH U - Austretender Gefahrstoff klein"],
			"TH U - Auslaufen von Kraftstoffen klein": ["TH U - Austretende Betriebsstoffe klein"],
			"TH U - Bio": ["TH U - Bio"],
			"TH U - Chemie": ["TH U - Austretender Gefahrstoff Gewässer", "TH U - Austretender Gefahrstoff groß", "TH U - Fahrzeug - Chemie", "TH U - Luftfahrzeug - Chemie", "TH U - Schienenfahrzeug - Chemie", "TH U - Wasserfahrzeug - Chemie"],
			"TH U - Messeinsatz groß": ["TH U - Messeinsatz groß"],
			"TH U - Messeinsatz klein": ["TH U - Geruch (Messeinsatz)", "TH U - Gewässerverunreinigung"],
			"TH VU - Boot": ["TH - Sicherung / Bergung Wasserfahrzeug", "TH - VU Motorboot / Sportboot"],
			"TH VU - Flugzeug 1": ["B - Kleinflugzeug / Hubschrauber", "B - Zeppelin / Ballon", "TH - Sicherung / Bergung Luftfahrzeug", "TH - VU Kleinflugzeug / Hubschrauber", "TH - VU Zeppelin / Ballon"],
			"TH VU - Flugzeug 2": ["B - Explosion Luftfahrzeug", "B - Luftfahrzeug sonstiges", "B - Passagier- / Verkehrsflugzeug", "B - Transport- / Militärflugzeug", "TH - VU Luftfahrzeug sonstiges", "TH - VU Passagier- / Verkehrsflugzeug", "TH - VU Transport- / Militärflugzeug"],
			"TH VU - Schiff": ["TH - VU Fahrgastschiff / Hafenfähre", "TH - VU Luftfahrzeug im Wasser", "TH - VU Transportschiff", "TH - VU Wasserfahrzeug sonstiges"],
        };
        // --- END AAO KEYWORDS ---
        
        
        // --- COMPATIBILITY FIX: Custom UUID Generator (V4) ---
        function generateUUID() {
            let d = new Date().getTime();
            let d2 = (performance && performance.now && (performance.now() * 1000)) || 0;
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                let r = Math.random() * 16;
                if (d > 0) {
                    r = (d + r) % 16 | 0;
                    d = Math.floor(d / 16);
                } else {
                    r = (d2 + r) % 16 | 0;
                    d2 = Math.floor(d2 / 16);
                }
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }
        // --- END COMPATIBILITY FIX ---

        // --- NEW: Helper function for category colors ---
        /**
         * Returns Tailwind CSS classes based on the category prefix.
         * @param {string} categoryName - The name of the category (e.g., "B 1", "S Erkundung").
         * @returns {{header: string, hover: string}}
         */
        function getCategoryColors(categoryName) {
            // "TH VU" (Dark Blue) must be checked before "TH U" and "TH"
            if (categoryName.startsWith("TH VU")) {
                return { 
                    header: 'text-blue-800 bg-blue-50 border-blue-200', 
                    hover: 'hover:bg-blue-100' 
                };
            }
            // "TH U" (Green) must be checked before "TH"
            if (categoryName.startsWith("TH U")) {
                return { 
                    header: 'text-green-700 bg-green-50 border-green-200', 
                    hover: 'hover:bg-green-100' 
                };
            }
            // "TH" (Light Blue)
            if (categoryName.startsWith("TH")) {
                return { 
                    header: 'text-sky-700 bg-sky-50 border-sky-200', 
                    hover: 'hover:bg-sky-100' 
                };
            }
            // "B" (Red)
            if (categoryName.startsWith("B")) {
                return { 
                    header: 'text-red-700 bg-red-50 border-red-200', 
                    hover: 'hover:bg-red-100' 
                };
            }
            // "S" (Yellow)
            if (categoryName.startsWith("S")) {
                return { 
                    header: 'text-yellow-700 bg-yellow-50 border-yellow-200', 
                    hover: 'hover:bg-yellow-100' 
                };
            }
            // Default (Grey)
            return { 
                header: 'text-gray-700 bg-gray-50 border-gray-200', 
                hover: 'hover:bg-gray-100' 
            };
        }
        // --- END NEW Helper ---

        // --- NEW: Helper to convert Hex to RGBA ---
        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) { // #RGB
                r = "0x" + hex[1] + hex[1];
                g = "0x" + hex[2] + hex[2];
                b = "0x" + hex[3] + hex[3];
            } else if (hex.length == 7) { // #RRGGBB
                r = "0x" + hex[1] + hex[2];
                g = "0x" + hex[3] + hex[4];
                b = "0x" + hex[5] + hex[6];
            }
            // Fallback for invalid hex
            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                return `rgba(79, 70, 229, ${alpha})`; // Default indigo
            }
            return `rgba(${+r},${+g},${+b},${alpha})`;
        }


        // --- Local State and Persistence ---
        const LOCAL_STORAGE_KEY = "localDispatchIncidents_v2"; 
        const LOCAL_STORAGE_SECTIONS_KEY = "localDispatchSections_v2"; 
        const LOCAL_STORAGE_HISTORY_KEY = "localDispatchIncidentHistory_v2"; 
        
        const incidents = new Map();
        const sections = new Map(); 
        const markers = new Map();
        const sectionPolygons = new Map(); // Map to store Leaflet Polygon layers
        
        let selectedIncidentId = null; 
        let editingIncidentId = null; // NEW: For edit modal
        let statusHistory = []; 
        let isCompletedSectionOpen = false;
        let isActiveSectionOpen = true; // NEW: State for active list
        
        // --- Drawing State ---
        let drawingSectionId = null;
        let currentDrawPoints = []; // Array of [lat, lon]
        const currentDrawLayer = new L.LayerGroup();
        const drawingIcon = L.divIcon({ className: 'leaflet-drawing-icon' });
        // NEW: Advanced drawing state
        let currentVertexMarkers = [];
        let currentPolyline = null;
        const SNAP_DISTANCE_PX = 20; // 20 pixels tolerance for snapping

        // --- Incident Mode State ---
        let isIncidentAddMode = false;
        let isIncidentEditMode = false; // NEW
        
        // --- UI Elements ---
        
        // --- Incident Creation Modal ---
        const dispatchForm = document.getElementById('dispatch-form');
        const addressInput = document.getElementById('address');
        const keywordInput = document.getElementById('keyword'); 
        const keywordSuggestionsContainer = document.getElementById('keyword-suggestions'); 
        const finalSectionAssignmentInput = document.getElementById('final-section-assignment'); 
        const autoSectionDisplay = document.getElementById('auto-section-display');
        const submitBtn = document.getElementById('submit-btn');
        const latInput = document.getElementById('lat-input');
        const lonInput = document.getElementById('lon-input');
        const suggestionsContainer = document.getElementById('address-suggestions'); 
        // Incident Add Mode UI (Global Panel)
        const addIncidentMapBtn = document.getElementById('add-incident-map-btn');
        const incidentAddPanel = document.getElementById('incident-add-panel');
        const cancelAddIncidentBtn = document.getElementById('cancel-add-incident-btn');


        // Sidebar UI
        const sidebarContainer = document.getElementById('sidebar-container');
        const incidentList = document.getElementById('incident-list');
        const completedIncidentList = document.getElementById('completed-incident-list');
        const completedToggleBtn = document.getElementById('completed-toggle-btn');
        const activeToggleBtn = document.getElementById('active-toggle-btn'); // NEW
        const statusIndicator = document.getElementById('status-indicator');
        const undoBtn = document.getElementById('undo-btn'); 
        
        // --- NEW: Incident Creation Modal UI ---
        const openCreateIncidentModalBtn = document.getElementById('open-create-incident-modal-btn');
        const incidentCreationModal = document.getElementById('incident-creation-modal');
        const closeIncidentModalBtn = document.getElementById('close-incident-modal-btn');
        
        // --- NEW: Incident Edit Modal UI ---
        const incidentEditModal = document.getElementById('incident-edit-modal');
        const incidentEditForm = document.getElementById('incident-edit-form');
        const closeIncidentEditModalBtn = document.getElementById('close-incident-edit-modal-btn');
        const editIncidentMapBtn = document.getElementById('edit-incident-map-btn');
        const editAddressInput = document.getElementById('edit-address');
        const editLatInput = document.getElementById('edit-lat-input');
        const editLonInput = document.getElementById('edit-lon-input');
        const editAddressSuggestions = document.getElementById('edit-address-suggestions');
        const editKeywordInput = document.getElementById('edit-keyword');
        const editKeywordSuggestions = document.getElementById('edit-keyword-suggestions');
        // const editStatusSelect = document.getElementById('edit-status'); // DELETED
        const editAutoSectionDisplay = document.getElementById('edit-auto-section-display');
        const deleteIncidentBtn = document.getElementById('delete-incident-btn');
        const saveIncidentBtn = document.getElementById('save-incident-btn');
        // Incident Edit Mode UI (Global Panel)
        const incidentEditPanel = document.getElementById('incident-edit-panel');
        const cancelEditIncidentBtn = document.getElementById('cancel-edit-incident-btn');
        // --- END NEW ---

        // --- NEW: EA Modal UI ---
        const manageEABtn = document.getElementById('manage-ea-btn');
        const eaManagementModal = document.getElementById('ea-management-modal');
        const closeEAModalBtn = document.getElementById('close-ea-modal-btn');
        
        // EA Management UI (now inside modal)
        const sectionForm = document.getElementById('section-form');
        const sectionNameInput = document.getElementById('section-name');
        const sectionResponsibleInput = document.getElementById('section-responsible');
        const sectionColorInput = document.getElementById('section-color'); // New
        let sectionListContainer = document.getElementById('section-list'); // Changed to let for re-assignment
        // const sectionMessage = document.getElementById('section-message'); // DELETED

        // NEW: Toast Container
        const toastContainer = document.getElementById('toast-container');
        
        // MOVED: EA Draw Panel (now global)
        const sectionDrawPanel = document.getElementById('section-draw-panel');
        const finishDrawBtn = document.getElementById('finish-draw-btn');
        const cancelDrawBtn = document.getElementById('cancel-draw-btn');
        
        // Offline Overlay & Data Containers (Updated)
        const offlineOverlay = document.getElementById('offline-overlay');
        const offlineEaList = document.getElementById('offline-ea-list');
        const offlineIncidentReport = document.getElementById('offline-incident-report');

        // --- NEW: End Shift Modal UI ---
        const endShiftBtn = document.getElementById('end-shift-btn');
        const endShiftModal = document.getElementById('end-shift-modal');
        const cancelReportBtn = document.getElementById('cancel-report-btn');
        const createReportBtn = document.getElementById('create-report-btn');
        const lagezeichnerInput = document.getElementById('lagezeichner-input');
        // const modalErrorMessage = document.getElementById('modal-error-message'); // DELETED
        // Report Stat Placeholders
        const reportStatsIncidents = document.getElementById('report-stats-incidents');
        const reportStatsEas = document.getElementById('report-stats-eas');
        const reportStatsDate = document.getElementById('report-stats-date');
        // --- END NEW ---

        let debounceTimer;
        let editDebounceTimer; // NEW
        
        // --- Map Initialization (Leaflet.js) ---
        const map = L.map('map').setView([49.0069, 8.4037], 13); // Centered on Karlsruhe
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        currentDrawLayer.addTo(map);
        
        // --- Central Map Click Handler (Refactored) ---
        function onMapClickHandler(e) {
            // Do not process clicks if offline overlay is active
            if (!offlineOverlay.classList.contains('hidden')) {
                return;
            }

            if (isIncidentAddMode) {
                // Handle adding an incident via map click
                handleMapAddIncidentClick(e);
            } else if (isIncidentEditMode) { // NEW
                // Handle editing an incident via map click
                handleMapEditIncidentClick(e);
            } else if (drawingSectionId) {
                // Handle drawing a section boundary
                handleMapDrawClick(e);
            } else {
                // Handle default deselection logic
                if (selectedIncidentId) { // Only re-render if something was selected
                    selectedIncidentId = null;
                    renderAllIncidents(); // Only re-render incidents
                }
            }
        }
        
        map.on('click', onMapClickHandler);
        // --- END Central Map Click Handler ---
        
        // --- Utility Functions ---

        /**
         * NEW: Creates a global toast notification.
         * @param {string} message - The text to display.
         * @param {boolean} isError - True for red (error), false for green (success).
         * @param {number} duration - How long to show the toast in ms. 0 for permanent.
         */
        function showMessage(message, isError = true, duration = 7000) {
            // Don't show messages if offline
            if (!offlineOverlay.classList.contains('hidden')) return;

            const toast = document.createElement('div');
            const iconSVG = isError ? 
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 mr-3 flex-shrink-0"><path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm-.28-4.47a.75.75 0 0 0-1.06-1.06L10 10.94l-1.72-1.72a.75.75 0 0 0-1.06 1.06L8.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L10 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L11.06 12l1.72-1.72Z" clip-rule="evenodd" /></svg>` :
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 mr-3 flex-shrink-0"><path fill-rule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm3.857-9.809a.75.75 0 0 0-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 1 0-1.06 1.061l2.5 2.5a.75.75 0 0 0 1.137-.089l4-5.5Z" clip-rule="evenodd" /></svg>`;
            
            // NEW: Close button
            // FIX: Replaced 'X' icon path with a more standard one.
            const closeBtnHTML = `
                <button class="toast-close-btn ml-3 -mr-1 p-1 rounded-full hover:bg-black hover:bg-opacity-10 transition-colors flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 pointer-events-none">
                        <path d="M4.75 4.75a.75.75 0 0 0 0 1.06L8.94 10l-4.19 4.19a.75.75 0 0 0 1.06 1.06L10 11.06l4.19 4.19a.75.75 0 0 0 1.06-1.06L11.06 10l4.19-4.19a.75.75 0 0 0-1.06-1.06L10 8.94 5.81 4.75a.75.75 0 0 0-1.06 0Z" />
                    </svg>
                </button>`;

            const baseClasses = 'p-4 rounded-lg shadow-lg flex items-start text-sm font-medium w-full toast-notification';
            const colorClasses = isError ? 
                'bg-red-100 text-red-700' : 
                'bg-green-100 text-green-700';

            toast.className = `${baseClasses} ${colorClasses}`;
            // UPDATED: Inner HTML with close button
            toast.innerHTML = `${iconSVG} <span class="flex-grow">${message}</span> ${closeBtnHTML}`;
            
            // Append to the *top* of the container
            toastContainer.prepend(toast);

            // Trigger enter animation
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });

            let autoDismissTimer;

            const removeToast = () => {
                clearTimeout(autoDismissTimer); // Clear auto-dismiss if manually closed
                toast.classList.remove('show');
                toast.classList.add('fade-out');
                // Remove element after fade-out animation completes
                toast.addEventListener('transitionend', () => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, { once: true }); // Ensure listener fires only once
            };

            // Add listener to the close button
            toast.querySelector('.toast-close-btn').addEventListener('click', removeToast);
            
            if(duration > 0) {
                // Set timeout to fade out and remove
                autoDismissTimer = setTimeout(removeToast, duration);
            }
        }
        
        // --- DEPRECATED: showSectionMessage, showFormMessage, showModalErrorMessage ---
        // All now use showMessage()


        function formatGermanAddress(address) {
            const parts = [];
            const street = address.road || '';
            const houseNumber = address.house_number || '';
            const postcode = address.postcode || '';
            const city = address.city || address.town || address.village || '';

            if (street) parts.push(`${street} ${houseNumber}`.trim());
            if (postcode && city) parts.push(`${postcode} ${city}`);
            else if (city && !parts.includes(city)) parts.push(city);
            
            const finalAddress = parts.join(', ');
            
            if (!finalAddress && address.display_name) {
                return address.display_name;
            }
            
            return finalAddress;
        }

        async function geocodeAddress(query) {
            if (!query || !navigator.onLine) return null;
            
            try {
                // Added viewbox for Karlsruhe area to prioritize local results
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=de&addressdetails=1&limit=1&viewbox=8.3,48.9,8.5,49.1&bounded=1`);
                const data = await await response.json();

                // Simple check for Karlsruher postcode area (76)
                const bestMatch = data.find(place => 
                    place.address && 
                    place.address.postcode && 
                    place.address.postcode.startsWith('76')
                );
                
                return bestMatch || data[0] || null; // Fallback to first result if no 76 match
            } catch (error) {
                console.error("Geocoding API error (Nominatim):", error);
                return null;
            }
        }

        // --- NEW: Reverse Geocoding Function ---
        async function reverseGeocode(lat, lon) {
            if (!navigator.onLine) {
                showMessage("Offline: Reverse-Geocoding nicht möglich.", true);
                return null;
            }
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`);
                const data = await response.json();

                if (data && data.address) {
                    const formattedAddress = formatGermanAddress(data.address);
                    return {
                        formattedAddress: formattedAddress,
                        lat: lat,
                        lon: lon
                    };
                } else {
                    return null;
                }
            } catch (error) {
                console.error("Reverse Geocoding API error (Nominatim):", error);
                return null;
            }
        }
        
        /**
         * Point-in-Polygon (PIP) Ray Casting Algorithm
         */
        function isPointInPolygon(point, polygon) {
            const x = point[0]; 
            const y = point[1]; 
            let inside = false;

            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                let xi = polygon[i][0], yi = polygon[i][1];
                let xj = polygon[j][0], yj = polygon[j][1];

                let intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                
                if (intersect) inside = !inside;
            }
            return inside;
        }

        /**
         * Determines which EA (if any) contains the given coordinates.
         */
        function findContainingSection(lat, lon) {
            let assignedSectionId = null;
            
            sections.forEach(section => {
                if (section.boundary && section.boundary.length >= 3) {
                    const point = [lat, lon];
                    if (isPointInPolygon(point, section.boundary)) {
                        assignedSectionId = section.id;
                    }
                }
            });
            return assignedSectionId;
        }
        
        // --- Geometric Helper Functions for Intersection Check ---
        
        function orientation(p, q, r) {
            const val = (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0]);

            if (Math.abs(val) < 1e-9) return 0; 
            return (val > 0) ? 1 : 2; 
        }

        function onSegment(p, q, r) {
            return (q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) &&
                    q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]));
        }

        function segmentsIntersect(p1, q1, p2, q2) {
            const o1 = orientation(p1, q1, p2);
            const o2 = orientation(p1, q1, q2);
            const o3 = orientation(p2, q2, p1);
            const o4 = orientation(p2, q2, q1);

            if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0 && o1 !== o2 && o3 !== o4) {
                return true;
            }
            return false;
        }
        
        /**
         * Checks if the proposed newBoundary intersects any existing EA boundary.
         */
        function checkExistingEAOverlaps(newBoundary, excludeSectionId) {
            let intersectionFound = false;

            sections.forEach(section => {
                if (section.id === excludeSectionId || !section.boundary || section.boundary.length < 3) {
                    return; 
                }
                
                const existingBoundary = section.boundary;
                
                for (let i = 0; i < newBoundary.length; i++) {
                    const p1 = newBoundary[i];
                    const q1 = newBoundary[(i + 1) % newBoundary.length]; 
                    for (let j = 0; j < existingBoundary.length; j++) {
                        const p2 = existingBoundary[j];
                        const q2 = existingBoundary[(j + 1) % existingBoundary.length]; 
                        
                        if (segmentsIntersect(p1, q1, p2, q2)) {
                            intersectionFound = true;
                            break;
                        }
                    }
                    if (intersectionFound) break;
                }
                if (intersectionFound) return; 
                
                if (isPointInPolygon(newBoundary[0], existingBoundary)) {
                    intersectionFound = true;
                    return; 
                }
                
                if (isPointInPolygon(existingBoundary[0], newBoundary)) {
                    intersectionFound = true;
                    return; 
                }
            });

            return intersectionFound;
        }
        
        /**
         * Iterates over all active incidents and re-runs the EA assignment logic.
         */
        function reEvaluateIncidents() {
            let assignmentsChanged = 0;
            incidents.forEach(incident => {
                if (incident.status !== 'completed') {
                    const newSectionId = findContainingSection(incident.lat, incident.lon);
                    if (incident.sectionId !== newSectionId) {
                        incident.sectionId = newSectionId;
                        assignmentsChanged++;
                    }
                }
            });
            if (assignmentsChanged > 0) {
                console.log(`Re-evaluierung: ${assignmentsChanged} Einsätze neu zugeordnet.`);
            }
        }


        // --- Persistence Logic ---

        function saveState() {
            const incidentsArray = Array.from(incidents.values());
            const sectionsArray = Array.from(sections.values());
            
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(incidentsArray));
            localStorage.setItem(LOCAL_STORAGE_SECTIONS_KEY, JSON.stringify(sectionsArray));
            localStorage.setItem(LOCAL_STORAGE_HISTORY_KEY, JSON.stringify(statusHistory));
            
            console.log("Lokaler Status gespeichert (Einsätze, Abschnitte, Verlauf).");
        }

        function loadState() {
            // 1. Load Sections
            const cachedSections = localStorage.getItem(LOCAL_STORAGE_SECTIONS_KEY);
            if (cachedSections) {
                try {
                    const sectionsArray = JSON.parse(cachedSections);
                    sectionsArray.forEach(section => {
                        if (!section.id) section.id = generateUUID();
                        if (typeof section.boundary === 'undefined') section.boundary = []; 
                        if (!section.color) section.color = '#4f46e5'; // Add default color
                        sections.set(section.id, section);
                    });
                    console.log(`Geladen: ${sections.size} Einsatzabschnitte.`);
                } catch (e) {
                    console.error("Fehler beim Laden der Einsatzabschnitte:", e);
                    localStorage.removeItem(LOCAL_STORAGE_SECTIONS_KEY);
                }
            }
            
            // 2. Load Incidents
            const cachedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (cachedData) {
                try {
                    const incidentsArray = JSON.parse(cachedData);
                    incidentsArray.forEach(incident => {
                        if (!incident.id) incident.id = generateUUID(); 
                        if (typeof incident.notes === 'undefined') incident.notes = '';
                        if (typeof incident.sectionId === 'undefined') incident.sectionId = null; 
                        incidents.set(incident.id, incident);
                    });
                    console.log(`Geladen: ${incidents.size} Einsätze aus dem lokalen Speicher.`);
                } catch (e) {
                    console.error("Fehler beim Laden der Einsätze:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                }
            }
            
            // 3. Load History
            const cachedHistory = localStorage.getItem(LOCAL_STORAGE_HISTORY_KEY);
            if (cachedHistory) {
                try {
                    statusHistory = JSON.parse(cachedHistory);
                } catch (e) {
                    console.error("Fehler beim Laden des Verlaufs:", e);
                    localStorage.removeItem(LOCAL_STORAGE_HISTORY_KEY);
                }
            }

            renderAll();
            updateUndoButtonState();
        }

        // --- Undo Logic ---

        function updateUndoButtonState() {
            undoBtn.disabled = statusHistory.length === 0;
            if (statusHistory.length > 0) {
                undoBtn.classList.replace('disabled:bg-gray-400', 'bg-yellow-500');
                undoBtn.classList.replace('disabled:text-white', 'text-gray-800'); 
            } else {
                undoBtn.classList.replace('bg-yellow-500', 'disabled:bg-gray-400');
                undoBtn.classList.replace('text-gray-800', 'disabled:text-white');
            }
        }

        function undoLastAction() {
            if (statusHistory.length === 0) return;

            const lastAction = statusHistory.pop();
            const incident = incidents.get(lastAction.id);

            if (incident) {
                incident.status = lastAction.oldStatus;
                // Re-assign to EA if being un-completed
                if (incident.status !== 'completed') {
                    incident.sectionId = findContainingSection(incident.lat, incident.lon); 
                } else {
                    incident.sectionId = null;
                }
                incidents.set(incident.id, incident);
                
                selectedIncidentId = null; 
                saveState();
                renderAll(); 
                
                showMessage(`Aktion für Einsatz ${lastAction.id.substring(0, 4)}... erfolgreich rückgängig gemacht.`, false);
            } else {
                showMessage("Fehler: Einsatz für Rückgängig-Aktion nicht gefunden. Verlauf wurde gelöscht.", true);
                statusHistory = []; 
            }

            updateUndoButtonState();
        }

        undoBtn.addEventListener('click', undoLastAction);
        
        // --- NEW: EA Modal Logic ---
        manageEABtn.addEventListener('click', () => {
            selectedIncidentId = null; // NEW: Collapse incident
            renderAllIncidents(); // NEW: Update UI
            eaManagementModal.classList.remove('hidden');
            renderSectionManager(); // Re-render list when opening
        });

        closeEAModalBtn.addEventListener('click', () => {
            if (drawingSectionId) {
                setDrawMode(false); // Cancel drawing if modal is closed
            }
            eaManagementModal.classList.add('hidden');
            renderAll(); // Re-render map polygons
        });

        // FIX: Add click-off-to-close listener
        eaManagementModal.addEventListener('click', (e) => {
            if (e.target === eaManagementModal) {
                if (drawingSectionId) {
                    setDrawMode(false); 
                }
                eaManagementModal.classList.add('hidden');
                renderAll(); 
            }
        });
        
        // --- REMOVED: Old listener for responsible person change ---
        // This is now handled by the "Save" button in the edit panel


        // --- Incident Add Mode Logic (UPDATED for Modal Flow) ---
        function setIncidentAddMode(isActive) {
            if (isActive) {
                // NEW: Ensure other modes are off
                setDrawMode(false);
                setIncidentEditMode(false);
                selectedIncidentId = null;
                renderAllIncidents(); // Collapse any open incidents
            }
            
            isIncidentAddMode = isActive;
            const mapContainer = map.getContainer();

            if (isActive) {
                mapContainer.classList.add('map-pin-mode'); // Use crosshair
                incidentAddPanel.classList.remove('hidden'); // Show global panel
                addIncidentMapBtn.disabled = true;
                submitBtn.disabled = true; // Keep submit disabled
                addIncidentMapBtn.textContent = 'Modus aktiv...';
            } else {
                mapContainer.classList.remove('map-pin-mode');
                incidentAddPanel.classList.add('hidden'); // Hide global panel
                addIncidentMapBtn.disabled = false;
                // Re-validate form to see if submit should be enabled
                validateIncidentForm(); 
                addIncidentMapBtn.textContent = 'Einsatz auf Karte hinzufügen (Pin-Tool)';
            }
        }

        async function handleMapAddIncidentClick(e) {
            if (!isIncidentAddMode) return;

            const lat = e.latlng.lat;
            const lon = e.latlng.lng;

            // Show loading state in panel
            incidentAddPanel.querySelector('p.text-sm').textContent = 'Suche Adresse...';
            
            const result = await reverseGeocode(lat, lon);
            
            if (result) {
                addressInput.value = result.formattedAddress;
                latInput.value = result.lat;
                lonInput.value = result.lon;
                
                updateAutoAssignment(result.lat, result.lon, 'auto-section-display');
                
                showMessage("Adresse von Karte übernommen. Bitte Stichwort eingeben.", false);
                
                setIncidentAddMode(false); // Turn off mode on success
                incidentCreationModal.classList.remove('hidden'); // RE-OPEN MODAL
                
                keywordInput.focus();
                validateIncidentForm(); // Check if form is now valid
            } else {
                showMessage("Adresse für den geklickten Punkt konnte nicht gefunden werden.", true);
                setIncidentAddMode(false); // Turn off mode on fail
                incidentCreationModal.classList.remove('hidden'); // RE-OPEN MODAL
            }
            // Reset panel text
            incidentAddPanel.querySelector('p.text-sm').textContent = 'Klicken Sie auf die Karte, um die Adresse zu füllen.';
        }
        
        // --- NEW: Incident Edit Mode Logic ---
        function setIncidentEditMode(isActive) {
            if (isActive) {
                // Ensure other modes are off
                setDrawMode(false);
                setIncidentAddMode(false);
                selectedIncidentId = null;
                renderAllIncidents(); // Collapse any open incidents
            }
            
            isIncidentEditMode = isActive;
            const mapContainer = map.getContainer();

            if (isActive) {
                mapContainer.classList.add('map-pin-mode'); // Use crosshair
                incidentEditPanel.classList.remove('hidden'); // Show global panel
                editIncidentMapBtn.disabled = true;
                editIncidentMapBtn.textContent = 'Modus aktiv...';
            } else {
                mapContainer.classList.remove('map-pin-mode');
                incidentEditPanel.classList.add('hidden'); // Hide global panel
                editIncidentMapBtn.disabled = false;
                editIncidentMapBtn.textContent = 'Neue Adresse von Karte wählen (Pin-Tool)';
            }
        }
        
        async function handleMapEditIncidentClick(e) {
            if (!isIncidentEditMode) return;

            const lat = e.latlng.lat;
            const lon = e.latlng.lng;

            // Show loading state in panel
            incidentEditPanel.querySelector('p.text-sm').textContent = 'Suche Adresse...';
            
            const result = await reverseGeocode(lat, lon);
            
            if (result) {
                // Update fields in the hidden edit modal
                editAddressInput.value = result.formattedAddress;
                editLatInput.value = result.lat;
                editLonInput.value = result.lon;
                
                updateAutoAssignment(result.lat, result.lon, 'edit-auto-section-display');
                
                showMessage("Neue Adresse von Karte übernommen.", false);
                
                setIncidentEditMode(false); // Turn off mode on success
                incidentEditModal.classList.remove('hidden'); // RE-OPEN MODAL
                
                editAddressInput.focus();
            } else {
                showMessage("Adresse für den geklickten Punkt konnte nicht gefunden werden.", true);
                setIncidentEditMode(false); // Turn off mode on fail
                incidentEditModal.classList.remove('hidden'); // RE-OPEN MODAL
            }
            // Reset panel text
            incidentEditPanel.querySelector('p.text-sm').textContent = 'Klicken Sie auf die Karte, um die Adresse zu ändern.';
        }


        // --- EA Drawing Logic (REFACTORED) ---
        
        /**
         * Finds the closest vertex (snap point) from other EAs within SNAP_DISTANCE_PX.
         */
        function findSnapPoint(clickedLatLng, excludeSectionId) {
            const clickedPoint = map.latLngToContainerPoint(clickedLatLng);
            let bestSnap = null;
            let minDistance = SNAP_DISTANCE_PX;

            sections.forEach((section, id) => {
                if (id === excludeSectionId || !section.boundary || section.boundary.length === 0) return;

                section.boundary.forEach(vertex => {
                    const vertexLatLng = L.latLng(vertex[0], vertex[1]);
                    const vertexPoint = map.latLngToContainerPoint(vertexLatLng);
                    const distance = clickedPoint.distanceTo(vertexPoint);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestSnap = vertexLatLng;
                    }
                });
            });
            return bestSnap;
        }

        /**
         * Updates the visual polyline based on the current state of currentDrawPoints.
         */
        function updateDrawPolyline() {
            const latlngs = currentDrawPoints.map(p => L.latLng(p[0], p[1]));
            if (currentPolyline) {
                currentPolyline.setLatLngs(latlngs);
            } else {
                currentPolyline = L.polyline(latlngs, { 
                    color: '#ef4444', 
                    weight: 3, 
                    opacity: 0.7 
                }).addTo(currentDrawLayer);
            }
        }

        /**
         * Creates a single draggable vertex marker.
         */
        function createVertexMarker(lat, lon, index) {
            const marker = L.marker([lat, lon], { 
                draggable: true, 
                icon: drawingIcon,
                autoPan: true
            }).addTo(currentDrawLayer);
            
            marker._vertexIndex = index; // Store index

            marker.on('drag', (e) => {
                const draggedMarker = e.target;
                const index = draggedMarker._vertexIndex;
                const newLatLng = draggedMarker.getLatLng();
                currentDrawPoints[index] = [newLatLng.lat, newLatLng.lng];
                updateDrawPolyline();
            });

            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e); // Stop click from propagating to map
                const clickedMarker = e.target;
                const indexToRemove = clickedMarker._vertexIndex;
                currentDrawPoints.splice(indexToRemove, 1);
                refreshDrawLayer(); // Rebuild all markers and polyline
            });
            
            currentVertexMarkers.push(marker);
            return marker;
        }

        /**
         * Rebuilds all markers and the polyline from currentDrawPoints.
         * Used after deleting a point to re-calculate indices.
         */
        function refreshDrawLayer() {
            currentDrawLayer.clearLayers();
            currentVertexMarkers = [];
            currentPolyline = null;
            
            const pointsToDraw = [...currentDrawPoints]; // Copy
            currentDrawPoints = []; // Reset

            pointsToDraw.forEach((p, i) => {
                createVertexMarker(p[0], p[1], i);
                currentDrawPoints.push([p[0], p[1]]); // Re-add to array in correct order
            });
            
            updateDrawPolyline();
        }

        function setDrawMode(isActive, sectionId = null) {
            if (isActive) {
                // NEW: Turn off other modes
                setIncidentAddMode(false);
                setIncidentEditMode(false);
                selectedIncidentId = null;
                renderAllIncidents(); // Collapse any open incidents
                
                incidentCreationModal.classList.add('hidden'); // Close incident modal if open
                incidentEditModal.classList.add('hidden'); // Close edit modal
            }

            drawingSectionId = isActive ? sectionId : null;
            const mapContainer = map.getContainer();
            
            if (isActive) {
                mapContainer.classList.add('map-draw-mode');
                // Show the global draw panel
                sectionDrawPanel.classList.remove('hidden');
                // Disable create button in modal (just in case)
                if (sectionForm) {
                    sectionForm.querySelector('button[type="submit"]').disabled = true;
                }
                
                // Load existing points
                currentDrawPoints = sections.get(sectionId)?.boundary ? [...sections.get(sectionId).boundary] : []; 
                refreshDrawLayer(); // Initial draw
            } else {
                mapContainer.classList.remove('map-draw-mode');
                // Hide the global draw panel
                sectionDrawPanel.classList.add('hidden');
                // Re-enable create button in modal
                if (sectionForm) {
                    sectionForm.querySelector('button[type="submit"]').disabled = false;
                }
                
                // Clear all drawing layers
                currentDrawLayer.clearLayers();
                currentDrawPoints = [];
                currentVertexMarkers = [];
                currentPolyline = null;
            }
            
            // Re-render the modal list (to update button states)
            renderSectionManager();
        }

        function handleMapDrawClick(e) {
            if (!drawingSectionId) return;
            
            // Find snap point
            const snappedLatLng = findSnapPoint(e.latlng, drawingSectionId);
            const newLat = snappedLatLng ? snappedLatLng.lat : e.latlng.lat;
            const newLon = snappedLatLng ? snappedLatLng.lng : e.latlng.lng;
            
            const newIndex = currentDrawPoints.length;
            currentDrawPoints.push([newLat, newLon]);
            createVertexMarker(newLat, newLon, newIndex);
            updateDrawPolyline();
            
            // Show message as a TOAST
            const section = sections.get(drawingSectionId);
            showMessage(`Punkt ${newIndex + 1} hinzugefügt für EA "${section.name}". ${snappedLatLng ? '(An Punkt angedockt)' : ''}`, false, 3000);
        }

        finishDrawBtn.addEventListener('click', () => {
            // Final points are already in currentDrawPoints, updated by drag events
            if (currentDrawPoints.length < 3) {
                // Show message as a TOAST
                showMessage("Ein Polygon benötigt mindestens 3 Punkte.", true);
                return;
            }
            
            if (checkExistingEAOverlaps(currentDrawPoints, drawingSectionId)) {
                // Show message as a TOAST
                showMessage("FEHLER: Die neue Grenze überschneidet oder überlappt einen bestehenden Einsatzabschnitt. Dies ist nicht erlaubt.", true);
                return;
            }

            const section = sections.get(drawingSectionId);
            if (section) {
                section.boundary = [...currentDrawPoints]; // Save a copy
                sections.set(drawingSectionId, section);
                saveState();
                
                reEvaluateIncidents();
                
                // Show message as a TOAST
                showMessage(`Grenze für EA "${section.name}" erfolgreich gespeichert. ${section.boundary.length} Punkte.`, false);
            }
            setDrawMode(false);
            renderAll(); // Re-render map and sidebar
        });

        cancelDrawBtn.addEventListener('click', () => {
            const section = sections.get(drawingSectionId);
            // Show message as a TOAST
            showMessage(`Zeichnen für EA "${section.name}" abgebrochen. Die alte Grenze (falls vorhanden) bleibt erhalten.`, true);
            setDrawMode(false);
            renderSectionManager(); // Re-render EA list
            renderAllIncidents(); // Re-render map polygons
        });
        
        // --- EA Management Logic ---

        sectionForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const name = sectionNameInput.value.trim();
            const responsible = sectionResponsibleInput.value.trim();
            const color = sectionColorInput.value;

            if (!name || !responsible) {
                showMessage("Bitte füllen Sie alle Felder aus.", true);
                return;
            }
            
            const newSection = {
                id: generateUUID(),
                name: name,
                responsible: responsible,
                boundary: [],
                color: color
            };

            sections.set(newSection.id, newSection);
            saveState();
            renderSectionManager(); // Only re-render the modal list
            showMessage(`EA "${name}" erfolgreich erstellt. Bitte definieren Sie nun die Grenze auf der Karte.`, false);
            sectionForm.reset();
            sectionColorInput.value = '#4f46e5'; // Reset color picker
        });

        function deleteSection(id) {
            // Do not use confirm() as it's blocked
            const section = sections.get(id);
            if (!section) return;
            
            // This is tricky. The old logic added a button to a message div.
            // The new logic uses toasts, which disappear.
            // For this *one case*, I will create a special persistent error toast.
            const toastMessage = `SIND SIE SICHER, dass Sie "${section.name}" löschen möchten? Alle Zuordnungen werden entfernt. 
                <button id="confirm-delete-${id}" class="mt-2 bg-red-700 text-white px-3 py-1 rounded text-xs font-bold w-full hover:bg-red-800">JA, LÖSCHEN</button>`;
            
            showMessage(toastMessage, true, 0); // Duration 0 means it stays until clicked

            // Need to add listener to the new button inside the toast
            // Use a timeout to ensure the element exists in the DOM
            setTimeout(() => {
                const confirmBtn = document.getElementById(`confirm-delete-${id}`);
                if (confirmBtn) {
                    confirmBtn.onclick = (e) => {
                        e.stopPropagation(); // Stop click from propagating
                        
                        if (drawingSectionId === id) setDrawMode(false);

                        sections.delete(id);
                        
                        incidents.forEach(incident => {
                            if (incident.sectionId === id) {
                                incident.sectionId = null;
                            }
                        });

                        reEvaluateIncidents(); 
                        
                        saveState();
                        renderAll(); // Full re-render
                        
                        // Manually close the toast
                        const parentToast = confirmBtn.closest('.toast-notification');
                        if (parentToast) {
                            parentToast.classList.remove('show');
                            parentToast.classList.add('fade-out');
                            parentToast.addEventListener('transitionend', () => {
                                if (parentToast.parentNode) {
                                    parentToast.parentNode.removeChild(parentToast);
                                }
                            }, { once: true });
                        }
                        
                        showMessage("EA gelöscht.", false); // Show new confirmation toast
                    };
                }
            }, 100); // 100ms delay
        }
        
        // --- UI Rendering ---

        function renderSectionManager() {
            // Only render if modal is visible
            if (eaManagementModal.classList.contains('hidden') && !drawingSectionId) {
                return;
            }

            if (!sectionListContainer) return; // Guard if element not found
            sectionListContainer.innerHTML = '';
            
            if (sections.size === 0) {
                sectionListContainer.innerHTML = '<p class="text-xs text-gray-500">Noch keine Einsatzabschnitte erstellt.</p>';
            }
            
            // Re-draw polygons on the main map
            sectionPolygons.forEach(polygon => map.removeLayer(polygon));
            sectionPolygons.clear();

            sections.forEach(section => {
                const count = Array.from(incidents.values()).filter(i => i.sectionId === section.id && i.status !== 'completed').length;
                const hasBoundary = section.boundary && section.boundary.length >= 3;
                const sectionColor = section.color || '#4f46e5'; // Fallback
                
                if (hasBoundary) {
                    const isDrawing = drawingSectionId === section.id;
                    const polygon = L.polygon(section.boundary, {
                        color: isDrawing ? '#ef4444' : sectionColor, 
                        fillColor: isDrawing ? '#fef2f2' : sectionColor, 
                        fillOpacity: 0.2,
                        weight: 2,
                        interactive: false // Makes polygon non-clickable
                    }).addTo(map);
                    
                    // NEW: Add permanent label to polygon
                    polygon.bindTooltip(
                        `<span style="color: ${sectionColor}; font-weight: bold; font-size: 14px; text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF, 0 0 4px #FFF;">${section.name}</span>`, {
                            permanent: true,
                            direction: 'center',
                            className: 'ea-label',
                            interactive: false
                        }
                    );
                    // END NEW

                    sectionPolygons.set(section.id, polygon);
                }

                // Render card in the modal list
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'flex flex-col p-3 bg-white rounded border-2';
                sectionDiv.style.borderColor = hasBoundary ? sectionColor : '#ef4444'; // Use sectionColor or red
                
                const boundaryStatusText = hasBoundary ? 
                    `<span class="text-xs font-medium text-green-700">✓ Grenze definiert</span>` : 
                    `<span class="text-xs font-medium text-red-700">✕ Grenze fehlt</span>`;

                const drawButtonHTML = hasBoundary ? 
                    `<button data-id="${section.id}" class="draw-section-btn bg-yellow-500 hover:bg-yellow-600 text-gray-800 font-bold py-1 px-2 rounded flex-grow text-xs transition duration-150">
                        Grenze bearbeiten
                    </button>` :
                    `<button data-id="${section.id}" class="draw-section-btn bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded flex-grow text-xs transition duration-150">
                        Grenze zeichnen
                    </button>`;


                // --- UPDATED: Section Card HTML with Edit Panel ---
                // FIX: Updated trash icon SVG path
                sectionDiv.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <p class="font-semibold text-lg" style="color: ${sectionColor};">${section.name} <span class="text-xs bg-gray-100 text-gray-600 px-1.5 py-0.5 rounded-full ml-1 font-medium">${count} Einsätze aktiv</span></p>
                            
                            <!-- Static Display -->
                            <p id="static-resp-${section.id}" class="text-sm text-gray-700 mt-2">
                                <strong>V:</strong> ${section.responsible}
                            </p>

                            <!-- EDIT PANEL (Hidden by default) -->
                            <div id="edit-panel-${section.id}" class="hidden mt-3 p-3 bg-gray-50 rounded shadow-inner space-y-2">
                                <h4 class="text-sm font-bold text-gray-800">EA Bearbeiten</h4>
                                <div>
                                    <label for="edit-resp-${section.id}" class="block text-xs text-gray-600 font-medium">Verantwortlicher:</label>
                                    <input type="text" id="edit-resp-${section.id}" class="shadow-sm appearance-none border rounded w-full py-1 px-2 text-gray-700 leading-tight text-xs" value="${section.responsible}">
                                </div>
                                <div>
                                    <label for="edit-color-${section.id}" class="block text-xs text-gray-600 font-medium">Farbe:</label>
                                    <input type="color" id="edit-color-${section.id}" class="shadow-sm appearance-none border rounded w-full h-8 p-0.5" value="${sectionColor}">
                                </div>
                                <div class="flex space-x-2">
                                    <button data-id="${section.id}" class="save-edit-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-2 rounded w-full text-xs transition duration-150">
                                        Speichern
                                    </button>
                                    <button data-id="${section.id}" class="cancel-edit-btn bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-1 px-2 rounded w-full text-xs transition duration-150">
                                        Abbrechen
                                    </button>
                                </div>
                            </div>
                            <!-- END EDIT PANEL -->

                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex-shrink-0 flex space-x-1 ml-2">
                            <button data-id="${section.id}" class="edit-ea-btn text-blue-600 hover:text-blue-800 p-1 rounded hover:bg-blue-100 transition duration-150" title="Abschnitt bearbeiten">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 pointer-events-none">
                                    <path d="M5.433 13.917l1.262-3.155A4 4 0 0 1 7.58 9.42l6.92-6.918a2.121 2.121 0 0 1 3 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 0 1-.65-.65Z" />
                                    <path d="M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0 0 10 3H4.75A2.75 2.75 0 0 0 2 5.75v9.5A2.75 2.75 0 0 0 4.75 18h9.5A2.75 2.75 0 0 0 17 15.25V10a.75.75 0 0 0-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5Z" />
                                </svg>
                            </button>
                            <button data-id="${section.id}" class="delete-section-btn text-red-500 hover:text-red-700 p-1 rounded hover:bg-red-100 transition duration-150" title="Abschnitt löschen">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 pointer-events-none">
                                    <path fill-rule="evenodd" d="M10 2a.75.75 0 0 1 .75.75v.75h4.5a.75.75 0 0 1 0 1.5h-1.5v9a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2v-9H4.5a.75.75 0 0 1 0-1.5h4.5V2.75A.75.75 0 0 1 10 2ZM8.5 7.5a.75.75 0 0 0-1.5 0v6a.75.75 0 0 0 1.5 0v-6Zm3 0a.75.75 0 0 0-1.5 0v6a.75.75 0 0 0 1.5 0v-6Z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex justify-between items-center space-x-2 mt-2 pt-2 border-t border-gray-100">
                        ${boundaryStatusText}
                        ${drawButtonHTML}
                    </div>
                `;
                // --- END UPDATED HTML ---
                sectionListContainer.appendChild(sectionDiv);
            });
            
            // --- NEW: Delegated Event Listener for Section List ---
            // Clear old listeners by replacing the node
            const newSectionListContainer = sectionListContainer.cloneNode(true);
            sectionListContainer.parentNode.replaceChild(newSectionListContainer, sectionListContainer);
            sectionListContainer = newSectionListContainer; // Re-assign variable

            sectionListContainer.addEventListener('click', (e) => {
                // Find the *closest* button to the click target
                const target = e.target.closest('button');
                if (!target) return;

                const id = target.dataset.id;
                
                // --- Delete Button ---
                if (target.classList.contains('delete-section-btn')) {
                    deleteSection(id);
                }
                
                // --- Draw Button ---
                else if (target.classList.contains('draw-section-btn')) {
                    setDrawMode(true, id);
                    eaManagementModal.classList.add('hidden'); // Close modal
                    // FIX: Use current zoom level instead of fixed '13'
                    map.flyTo(map.getCenter(), map.getZoom());
                }
                
                // --- Edit Button (NEW) ---
                else if (target.classList.contains('edit-ea-btn')) {
                    document.getElementById(`edit-panel-${id}`).classList.toggle('hidden');
                    document.getElementById(`static-resp-${id}`).classList.toggle('hidden');
                }
                
                // --- Cancel Edit Button (NEW) ---
                else if (target.classList.contains('cancel-edit-btn')) {
                    document.getElementById(`edit-panel-${id}`).classList.add('hidden');
                    document.getElementById(`static-resp-${id}`).classList.remove('hidden');
                    // Reset fields to original values from section object
                    const section = sections.get(id);
                    if (section) {
                        document.getElementById(`edit-resp-${id}`).value = section.responsible;
                        document.getElementById(`edit-color-${id}`).value = section.color;
                    }
                }
                
                // --- Save Edit Button (NEW) ---
                else if (target.classList.contains('save-edit-btn')) {
                    const section = sections.get(id);
                    if (!section) return;

                    const newResp = document.getElementById(`edit-resp-${id}`).value.trim();
                    const newColor = document.getElementById(`edit-color-${id}`).value;
                    
                    if (!newResp) {
                        showMessage("Name des Verantwortlichen darf nicht leer sein.", true);
                        return;
                    }
                    
                    section.responsible = newResp;
                    section.color = newColor;
                    sections.set(id, section);
                    
                    saveState();
                    renderAll(); // Full re-render to update map and list
                    renderSectionManager(); // Re-render modal list
                    
                    showMessage(`EA "${section.name}" erfolgreich aktualisiert.`, false);
                    
                    // Manually hide panel after save (renderAll might be too slow)
                    document.getElementById(`edit-panel-${id}`).classList.add('hidden');
                    document.getElementById(`static-resp-${id}`).classList.remove('hidden');
                }
            });
            // --- END NEW Delegated Listener ---
        }
        
        function getStatusColor(status) {
            if (status === 'open') return 'red';
            if (status === 'dispatched') return 'blue';
            if (status === 'completed') return 'amber'; 
            return 'grey';
        }

        function createMarkerIcon(color) {
            const hexColor = {
                'red': '#ef4444', 
                'blue': '#3b82f6', 
                'amber': '#f59e0b',
                'grey': '#6b7280',
                'magenta': '#E600E6' // For selected incident
            }[color];
            
            // FIX: Removed glow effect by setting selectedEffect to an empty string
            const selectedEffect = ''; // OLD: color === 'magenta' ? 'drop-shadow(0 0 5px #E600E6)' : '';
            
            const svgIcon = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="${hexColor}" width="36px" height="36px" style="filter: ${selectedEffect};">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>`;
            return L.divIcon({
                html: svgIcon,
                className: '',
                iconSize: [36, 36],
                iconAnchor: [18, 36],
                popupAnchor: [0, -36]
            });
        }

        function getGermanStatusText(status) {
            if (status === 'open') return 'OFFEN';
            if (status === 'dispatched') return 'ENTSANDT';
            if (status === 'completed') return 'ABGESCHLOSSEN';
            return 'UNBEKANNT';
        }

        function renderIncidentCard(incident) {
            const isCompleted = incident.status === 'completed';
            const currentSection = incident.sectionId ? sections.get(incident.sectionId) : null;

            const incidentElement = document.createElement('div');
            incidentElement.id = `incident-${incident.id}`;
            
            let statusColorClass = 'bg-gray-100 text-gray-800 border-l-4 border-gray-300';
            let buttonHTML = '';
            
            if (incident.status === 'open') {
                statusColorClass = 'bg-red-100 text-red-800 border-l-4 border-red-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn dispatch-btn bg-green-500 hover:bg-green-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Einheit entsenden</button>`;
            } else if (incident.status === 'dispatched') {
                statusColorClass = 'bg-blue-100 text-blue-800 border-l-4 border-blue-500';
                buttonHTML = `<button data-id="${incident.id}" class="update-status-btn complete-btn bg-blue-500 hover:bg-blue-600 text-white text-sm font-bold py-1 px-3 rounded w-full transition duration-150">Als abgeschlossen markieren</button>`;
            } else if (incident.status === 'completed') {
                statusColorClass = 'bg-amber-100 text-amber-800 opacity-75 border-l-4 border-amber-500';
                buttonHTML = `<button disabled class="bg-gray-300 text-gray-700 text-sm font-bold py-1 px-3 rounded w-full cursor-not-allowed">Abgeschlossen</button>`;
            }
            
            let selectionClass = '';
            let notesSectionHTML = '';
            let sectionInfoHTML = '';

            if (currentSection) {
                const sectionColor = currentSection.color || '#4f46e5';
                sectionInfoHTML = `
                <div class="mt-2 text-xs font-medium p-1.5 rounded flex justify-between items-center" style="background-color: ${hexToRgba(sectionColor, 0.1)};">
                    <span style="color: ${sectionColor};"><strong>EA: ${currentSection.name}</strong> (V: ${currentSection.responsible})</span>
                    <button data-id="${incident.id}" class="unassign-section-btn text-red-500 hover:text-red-700 p-0.5 rounded transition duration-150" title="EA-Zuordnung manuell aufheben">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-4 h-4 pointer-events-none">
                            <path d="M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" />
                        </svg>
                    </button>
                </div>`;
            } else if (!isCompleted) {
                 sectionInfoHTML = `<div class="mt-2 text-xs text-gray-600 font-medium bg-gray-200 p-1.5 rounded">
                    EA: Nicht zugeordnet (Keine Grenze gefunden)
                </div>`;
            }

            if (incident.id === selectedIncidentId) {
                selectionClass = 'incident-selected';
                setTimeout(() => {
                    const el = document.getElementById(incidentElement.id);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 50);

                // Show notes section for *all* selected incidents, even completed
                notesSectionHTML = `
                    <div class="mt-4 p-3 bg-white rounded-md border border-gray-300 shadow-inner">
                        <label for="notes-${incident.id}" class="block text-gray-700 text-sm font-bold mb-1">Notizen/Details</label>
                        <textarea id="notes-${incident.id}" class="notes-textarea shadow-sm appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-indigo-500" rows="3" placeholder="Geben Sie hier wichtige Informationen zum Einsatz ein..." ${isCompleted ? 'disabled' : ''}>${incident.notes || ''}</textarea>
                        ${!isCompleted ? `
                        <button data-id="${incident.id}" class="save-notes-btn mt-2 bg-indigo-500 hover:bg-indigo-600 text-white text-sm font-bold py-1 px-3 rounded transition duration-150 w-full disabled:bg-indigo-300">
                            Notizen speichern
                        </button>
                        ` : ''}
                    </div>
                `;
            }


            incidentElement.innerHTML = `
                <div class="flex justify-between items-start">
                    <div class="flex-grow">
                        <p class="font-semibold text-gray-800 pr-2">${incident.keyword}</p>
                        <p class="text-sm text-gray-600">${incident.formattedAddress}</p>
                    </div>
                    <!-- NEW: Edit Button -->
                    <button data-id="${incident.id}" class="edit-incident-btn flex-shrink-0 text-blue-600 hover:text-blue-800 p-1 rounded hover:bg-blue-100 transition duration-150" title="Einsatz bearbeiten">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5 pointer-events-none">
                           <path d="M5.433 13.917l1.262-3.155A4 4 0 0 1 7.58 9.42l6.92-6.918a2.121 2.121 0 0 1 3 3l-6.92 6.918c-.383.383-.84.685-1.343.886l-3.154 1.262a.5.5 0 0 1-.65-.65Z" />
                           <path d="M3.5 5.75c0-.69.56-1.25 1.25-1.25H10A.75.75 0 0 0 10 3H4.75A2.75 2.75 0 0 0 2 5.75v9.5A2.75 2.75 0 0 0 4.75 18h9.5A2.75 2.75 0 0 0 17 15.25V10a.75.75 0 0 0-1.5 0v5.25c0 .69-.56 1.25-1.25 1.25h-9.5c-.69 0-1.25-.56-1.25-1.25v-9.5Z" />
                        </svg>
                    </button>
                    <!-- END NEW: Edit Button -->
                </div>
                <div class="mt-2">
                    <span class="status-tag text-xs font-medium mr-2 px-2.5 py-0.5 rounded ${statusColorClass.split(' ').filter(c => !c.startsWith('border-')).join(' ')}">${getGermanStatusText(incident.status)}</span>
                </div>
                ${sectionInfoHTML}
                ${notesSectionHTML} 
                <div class="button-container mt-2 space-y-2">${buttonHTML}</div>
            `;
            // UPDATED: Removed cursor-pointer from completed cards
            incidentElement.className = `p-3 bg-gray-50 border rounded-lg shadow-sm ${statusColorClass} ${selectionClass} ${isCompleted ? 'cursor-default' : 'cursor-pointer'}`;
            return incidentElement;
        }


        function renderAllIncidents() {
            incidentList.innerHTML = '';
            completedIncidentList.innerHTML = '';
            markers.forEach(marker => map.removeLayer(marker));
            markers.clear();
            
            // Re-draw map polygons (necessary in case EA modal was closed)
            sectionPolygons.forEach(polygon => map.removeLayer(polygon));
            sectionPolygons.clear();
            sections.forEach(section => {
                if (section.boundary && section.boundary.length >= 3) {
                    const sectionColor = section.color || '#4f46e5';
                    const polygon = L.polygon(section.boundary, {
                        color: sectionColor, 
                        fillColor: sectionColor, 
                        fillOpacity: 0.2,
                        weight: 2,
                        interactive: false
                    }).addTo(map);

                    // NEW: Add permanent label to polygon
                    polygon.bindTooltip(
                        `<span style="color: ${sectionColor}; font-weight: bold; font-size: 14px; text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF, 0 0 4px #FFF;">${section.name}</span>`, {
                            permanent: true,
                            direction: 'center',
                            className: 'ea-label',
                            interactive: false
                        }
                    );
                    // END NEW
                    
                    sectionPolygons.set(section.id, polygon);
                }
            });

            const activeIncidents = [];
            const completedIncidents = [];

            incidents.forEach(incident => {
                if (incident.status === 'completed') {
                    completedIncidents.push(incident);
                } else {
                    activeIncidents.push(incident);
                }
            });

            // --- RENDER ACTIVE INCIDENTS ---
            activeIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                incidentList.appendChild(incidentElement);

                incidentElement.addEventListener('click', (e) => {
                    // Stop propagation if clicking on an interactive element
                    if (e.target.closest('button') || e.target.closest('textarea') || e.target.closest('.notes-textarea')) {
                        return;
                    }

                    if (selectedIncidentId === incident.id) {
                        selectedIncidentId = null;
                    } else {
                        selectedIncidentId = incident.id;
                        map.flyTo([incident.lat, incident.lon], 15); 
                    }
                    
                    renderAllIncidents(); // Only re-render incidents
                });

                if (incident.lat && incident.lon) {
                    // NEW: Check if selected
                    const isSelected = incident.id === selectedIncidentId;
                    const color = isSelected ? 'magenta' : getStatusColor(incident.status);
                    
                    const newIcon = createMarkerIcon(color);
                    const germanStatus = getGermanStatusText(incident.status);
                    const sectionName = (incident.sectionId && sections.get(incident.sectionId)) ? sections.get(incident.sectionId).name : 'Kein EA';
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${germanStatus}<br>EA: ${sectionName}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { 
                        icon: newIcon,
                        zIndexOffset: isSelected ? 1000 : 0 // Make selected marker on top
                    }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    
                    newMarker.on('click', function(e) {
                        if (selectedIncidentId !== incident.id) {
                            selectedIncidentId = incident.id;
                            renderAllIncidents(); // Re-render list and markers
                        }
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });

            // --- RENDER COMPLETED INCIDENTS ---
            completedIncidents.forEach(incident => {
                const incidentElement = renderIncidentCard(incident);
                completedIncidentList.appendChild(incidentElement);
                
                 incidentElement.addEventListener('click', (e) => {
                    // Stop propagation if clicking on an interactive element
                    if (e.target.closest('button') || e.target.closest('textarea') || e.target.closest('.notes-textarea')) {
                        return;
                    }
                    
                    if (selectedIncidentId === incident.id) {
                        selectedIncidentId = null;
                    } else {
                        selectedIncidentId = incident.id;
                        map.flyTo([incident.lat, incident.lon], 15); 
                    }
                    renderAllIncidents(); // Re-render list and markers
                });

                if (incident.lat && incident.lon) {
                    // NEW: Check if selected
                    const isSelected = incident.id === selectedIncidentId;
                    const color = isSelected ? 'magenta' : getStatusColor(incident.status);
                    
                    const newIcon = createMarkerIcon(color);
                    const germanStatus = getGermanStatusText(incident.status);
                    const sectionName = (incident.sectionId && sections.get(incident.sectionId)) ? sections.get(incident.sectionId).name : 'Kein EA';
                    const popupContent = `<b>${incident.keyword}</b><br>${incident.formattedAddress}<br>Status: ${germanStatus}<br>EA: ${sectionName}`;
                    
                    const newMarker = L.marker([incident.lat, incident.lon], { 
                        icon: newIcon,
                        zIndexOffset: isSelected ? 1000 : 0 // Make selected marker on top
                    }).addTo(map);
                    newMarker.bindPopup(popupContent);
                    newMarker.on('click', function(e) {
                        if (selectedIncidentId !== incident.id) {
                            selectedIncidentId = incident.id;
                            renderAllIncidents(); // Re-render list and markers
                        }
                        map.flyTo([incident.lat, incident.lon], map.getZoom()); 
                    });

                    markers.set(incident.id, newMarker);
                }
            });
            
            // --- NEW: Update Active Toggle Button ---
            const activeToggleIconText = isActiveSectionOpen ? '▲' : '▼';
            activeToggleBtn.innerHTML = `Aktive Einsätze (${activeIncidents.length}) <span class="text-lg font-mono">${activeToggleIconText}</span>`;
            // --- END NEW ---

            const completedToggleIconText = isCompletedSectionOpen ? '▲' : '▼';
            completedToggleBtn.innerHTML = `Abgeschlossene Einsätze (${completedIncidents.length}) <span class="text-lg font-mono">${completedToggleIconText}</span>`;
            
            updateUndoButtonState();
        }

        function renderAll() {
            // renderSectionManager is now only called when modal opens
            // or when drawing finishes
            renderAllIncidents();
        }

        // --- Notes Saving and EA Changing Logic ---
        sidebarContainer.addEventListener('click', (e) => {
            // Find the closest *button* to the click target
            const target = e.target.closest('button');
            if (!target) return;
            
            const id = target.dataset.id;
            const incident = incidents.get(id);
            
            if (target.classList.contains('save-notes-btn')) {
                const notesTextarea = document.getElementById(`notes-${id}`);
                if (!incident || !notesTextarea) return;

                incident.notes = notesTextarea.value.trim();
                incidents.set(id, incident);
                
                saveState();
                
                const originalText = target.textContent;
                target.textContent = 'Gespeichert!';
                target.disabled = true;

                setTimeout(() => {
                    target.textContent = originalText;
                    target.disabled = false;
                }, 1500);
                
                selectedIncidentId = id; 
                showMessage("Notizen erfolgreich gespeichert.", false);
                
            } else if (target.classList.contains('unassign-section-btn')) {
                if (!incident) return;
                
                const oldSectionName = (incident.sectionId && sections.get(incident.sectionId)) ? sections.get(incident.sectionId).name : 'Unbekannt';
                incident.sectionId = null; 
                incidents.set(id, incident);
                
                saveState();
                selectedIncidentId = null; // NEW: Collapse card
                renderAll();
                
                showMessage(`EA-Zuordnung für Einsatz ${id.substring(0, 4)}... (vormals ${oldSectionName}) manuell aufgehoben.`, false);
                
            } else if (target.classList.contains('edit-incident-btn')) { // NEW: Open Edit Modal
                if (!incident) return;
                
                editingIncidentId = id;
                
                // Populate modal
                editKeywordInput.value = incident.keyword;
                editAddressInput.value = incident.formattedAddress;
                editLatInput.value = incident.lat;
                editLonInput.value = incident.lon;
                
                // FIX: Use new button state function instead of select
                setEditStatusButtonState(incident.status);
                
                // Set initial EA display
                updateAutoAssignment(incident.lat, incident.lon, 'edit-auto-section-display');
                
                // Clear suggestions
                editAddressSuggestions.classList.add('hidden');
                editKeywordSuggestions.classList.add('hidden');
                
                incidentEditModal.classList.remove('hidden');
                
            } else if (target.classList.contains('update-status-btn')) { // Status Update
                if (!incident) return;
            
                let oldStatus = incident.status;
                let newStatus;
                let message = '';

                if (target.classList.contains('dispatch-btn')) {
                    newStatus = 'dispatched';
                    message = 'entsandt.';
                } else if (target.classList.contains('complete-btn')) {
                    newStatus = 'completed'; 
                    message = 'als abgeschlossen markiert.';
                } else {
                    return; 
                }

                if (oldStatus !== newStatus) {
                    statusHistory.push({
                        id: id,
                        oldStatus: oldStatus,
                        newStatus: newStatus
                    });
                }
                
                incident.status = newStatus;
                
                if (newStatus === 'completed') {
                    incident.sectionId = null; // Un-assign from EA on completion
                }
                
                incidents.set(id, incident);
                selectedIncidentId = null; // NEW: Collapse card
                saveState();
                renderAll(); 
                showMessage(`Einsatz ${id.substring(0, 4)}... ${message}`, false);
            }
        });


        // --- Helper for Offline Report ---
        /**
         * Builds an HTML block for a specific category of incidents for the offline report.
         * @param {string} title - The title of the category (e.g., "Offene Einsätze").
         * @param {Array} incidentArray - The array of incident objects.
         * @param {string} titleColorClass - The Tailwind CSS class for the title color.
         * @returns {string} The generated HTML string.
         */
        function buildOfflineIncidentCategory(title, incidentArray, titleColorClass) {
            let html = `<div class="mb-4">
                            <h4 class="text-lg font-bold ${titleColorClass} mb-2 pb-1 border-b border-gray-300">${title} (${incidentArray.length})</h4>`;
            
            if (incidentArray.length > 0) {
                html += '<div class="space-y-3">';
                incidentArray.forEach(incident => {
                    const section = incident.sectionId ? sections.get(incident.sectionId) : null;
                    // Handle display for completed incidents
                    const sectionName = section ? `${section.name} (${section.responsible})` : (incident.status === 'completed' ? 'N/A (Abgeschlossen)' : 'Kein EA');
                    
                    let notesHTML = '';
                    if (incident.notes && incident.notes.trim() !== '') {
                        notesHTML = `
                            <div class="mt-2 pt-2 border-t border-gray-200">
                                <p class="text-xs font-bold text-gray-600 mb-1">Notizen:</p>
                                <p class="text-sm text-gray-800 whitespace-pre-wrap">${incident.notes}</p>
                            </div>`;
                    } else {
                        notesHTML = `
                            <div class="mt-2 pt-2 border-t border-gray-200">
                                <p class="text-sm text-gray-500 italic">Keine Notizen.</p>
                            </div>`;
                    }

                    html += `
                        <div class="p-3 bg-white border border-gray-300 rounded shadow-sm">
                            <p class="font-bold text-lg text-gray-800">${incident.keyword}</p>
                            <p class="text-sm font-medium text-gray-800">${incident.formattedAddress}</p>
                            <p class="text-sm text-indigo-700 font-semibold mt-1">EA: ${sectionName}</p>
                            ${notesHTML}
                        </div>`;
                });
                html += '</div>';
            } else {
                html += '<p class="text-sm text-gray-500 italic">Keine Einsätze in dieser Kategorie.</p>';
            }
            html += '</div>';
            return html;
        }


        // --- Network and Address Lookup Management (REBUILT FOR SAFE STATE) ---
        
        function setOnlineStatus(isOnline) {
            if (isOnline) {
                // --- RE-ENABLE THE APP ---
                statusIndicator.textContent = 'Online: Adresssuche aktiv';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-medium transition duration-300 bg-green-100 text-green-700';
                
                // Hide the overlay
                offlineOverlay.classList.add('hidden');
                
                // Clear the report data
                offlineEaList.innerHTML = '';
                offlineIncidentReport.innerHTML = '';

                // Re-enable map interactions
                map.dragging.enable();
                map.touchZoom.enable();
                map.doubleClickZoom.enable();
                map.scrollWheelZoom.enable();
                map.boxZoom.enable();

            } else {
                // --- ENTER SAFE STATE ---
                statusIndicator.textContent = 'OFFLINE - SICHERHEITSMODUS';
                statusIndicator.className = 'text-sm p-2 mb-4 rounded text-center font-bold transition duration-300 bg-red-700 text-white animate-pulse';

                // Cancel any active modes BEFORE showing overlay
                if (drawingSectionId) setDrawMode(false);
                if (isIncidentAddMode) setIncidentAddMode(false);
                if (isIncidentEditMode) setIncidentEditMode(false); // NEW
                
                // Close modals
                eaManagementModal.classList.add('hidden');
                incidentCreationModal.classList.add('hidden');
                incidentEditModal.classList.add('hidden'); // NEW
                endShiftModal.classList.add('hidden');
                
                // Ensure no incident is selected (to close notes)
                if (selectedIncidentId) {
                    selectedIncidentId = null;
                    renderAll(); // Re-render to close notes box
                }

                // --- POPULATE OFFLINE REPORT ---
                
                // 1. Clear old data
                offlineEaList.innerHTML = '';
                offlineIncidentReport.innerHTML = '';
                
                // 2. Populate EAs
                if (sections.size > 0) {
                    sections.forEach(section => {
                        const eaDiv = document.createElement('div');
                        eaDiv.className = 'p-2 bg-white border border-indigo-200 rounded';
                        eaDiv.innerHTML = `
                            <p class="font-bold text-indigo-700">${section.name}</p>
                            <p class="text-sm text-gray-600">Verantwortlich: ${section.responsible}</p>
                        `;
                        offlineEaList.appendChild(eaDiv);
                    });
                } else {
                    offlineEaList.innerHTML = '<p class="text-sm text-gray-500 italic">Keine Einsatzabschnitte definiert.</p>';
                }

                // 3. Populate Incidents by Category (UPDATED)
                const openIncidents = Array.from(incidents.values()).filter(i => i.status === 'open');
                const dispatchedIncidents = Array.from(incidents.values()).filter(i => i.status === 'dispatched');
                const completedIncidents = Array.from(incidents.values()).filter(i => i.status === 'completed');

                offlineIncidentReport.innerHTML += buildOfflineIncidentCategory('Offene Einsätze', openIncidents, 'text-red-700');
                offlineIncidentReport.innerHTML += buildOfflineIncidentCategory('Entsandte Einsätze', dispatchedIncidents, 'text-blue-700');
                offlineIncidentReport.innerHTML += buildOfflineIncidentCategory('Abgeschlossene Einsätze', completedIncidents, 'text-amber-700');
                
                // --- END POPULATE OFFLINE REPORT ---
                
                // Show the overlay to block all clicks
                offlineOverlay.classList.remove('hidden');

                // Disable map interactions
                map.dragging.disable();
                map.touchZoom.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
                map.boxZoom.disable();
                
                // Save state one last time (just in case)
                saveState();
            }
        }
        
        window.addEventListener('online', () => setOnlineStatus(true));
        window.addEventListener('offline', () => setOnlineStatus(false));
        // Initial check on load
        // setOnlineStatus(navigator.onLine); // Set in window.onload


        /**
         * Updates the auto-assignment display text in a given modal.
         * @param {number} lat - Latitude.
         * @param {number} lon - Longitude.
         * @param {string} displayElementId - The ID of the text element to update.
         */
        function updateAutoAssignment(lat, lon, displayElementId) {
            const displayElement = document.getElementById(displayElementId);
            if (!displayElement) return;

            const sectionId = findContainingSection(lat, lon);
            
            if (sectionId) {
                const section = sections.get(sectionId);
                const sectionColor = section.color || '#4f46e5';
                displayElement.textContent = `EA: ${section.name} (V: ${section.responsible})`;
                displayElement.style.color = sectionColor;
                displayElement.classList.remove('text-red-700', 'text-gray-700');
            } else {
                displayElement.textContent = 'Keinem EA zugeordnet';
                displayElement.style.color = ''; // Reset style
                displayElement.classList.remove('text-indigo-700', 'text-gray-700');
                displayElement.classList.add('text-red-700');
            }
        }

        // --- NEW: Incident Form Validation ---
        function validateIncidentForm() {
            const address = addressInput.value.trim();
            const keyword = keywordInput.value.trim();
            
            if (address !== '' && keyword !== '') {
                submitBtn.disabled = false;
            } else {
                submitBtn.disabled = true;
            }
        }
        
        // --- Address Autocomplete (Creation Modal) ---
        addressInput.addEventListener('input', () => {
            validateIncidentForm(); // Validate on input
            
            clearTimeout(debounceTimer);
            const query = addressInput.value;
            
            latInput.value = '';
            lonInput.value = '';
            
            updateAutoAssignment(0, 0, 'auto-section-display'); // Reset display
            autoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
            autoSectionDisplay.classList.add('text-gray-700');
            autoSectionDisplay.classList.remove('text-red-700', 'text-indigo-700');


            if (query.length < 3 || !navigator.onLine) {
                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.add('hidden');
                return;
            }
            
            debounceTimer = setTimeout(async () => {
                const data = await geocodeAddress(query);

                suggestionsContainer.innerHTML = '';
                suggestionsContainer.classList.remove('hidden');

                if (data) {
                    const formattedAddress = formatGermanAddress(data.address);
                    const suggestionItem = document.createElement('div');
                    suggestionItem.textContent = formattedAddress;
                    suggestionItem.className = 'p-2 cursor-pointer hover:bg-gray-100 transition duration-100 suggestion-item';
                    
                    suggestionItem.addEventListener('click', () => {
                        addressInput.value = formattedAddress;
                        latInput.value = data.lat; 
                        lonInput.value = data.lon;

                        suggestionsContainer.classList.add('hidden');
                        suggestionsContainer.innerHTML = '';
                        
                        const lat = parseFloat(data.lat);
                        const lon = parseFloat(data.lon);
                        updateAutoAssignment(lat, lon, 'auto-section-display');
                        validateIncidentForm(); // Re-validate after selection
                    });
                    suggestionsContainer.appendChild(suggestionItem);
                } else {
                    suggestionsContainer.innerHTML = '<div class="p-2 text-gray-500">Keine passende 76... Adresse gefunden.</div>';
                    updateAutoAssignment(0, 0, 'auto-section-display');
                    autoSectionDisplay.textContent = 'Keine Geo-Daten gefunden';
                }
            }, 300);
        });
        
        // --- NEW: Address Autocomplete (Edit Modal) ---
        editAddressInput.addEventListener('input', () => {
            clearTimeout(editDebounceTimer);
            const query = editAddressInput.value;
            
            editLatInput.value = '';
            editLonInput.value = '';

            updateAutoAssignment(0, 0, 'edit-auto-section-display'); // Reset display
            editAutoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
            editAutoSectionDisplay.classList.add('text-gray-700');
            editAutoSectionDisplay.classList.remove('text-red-700', 'text-indigo-700');
            
            if (query.length < 3 || !navigator.onLine) {
                editAddressSuggestions.innerHTML = '';
                editAddressSuggestions.classList.add('hidden');
                return;
            }
            
            editDebounceTimer = setTimeout(async () => {
                const data = await geocodeAddress(query);

                editAddressSuggestions.innerHTML = '';
                editAddressSuggestions.classList.remove('hidden');

                if (data) {
                    const formattedAddress = formatGermanAddress(data.address);
                    const suggestionItem = document.createElement('div');
                    suggestionItem.textContent = formattedAddress;
                    suggestionItem.className = 'p-2 cursor-pointer hover:bg-gray-100 transition duration-100 suggestion-item';
                    
                    suggestionItem.addEventListener('click', () => {
                        editAddressInput.value = formattedAddress;
                        editLatInput.value = data.lat; 
                        editLonInput.value = data.lon;

                        editAddressSuggestions.classList.add('hidden');
                        editAddressSuggestions.innerHTML = '';
                        
                        const lat = parseFloat(data.lat);
                        const lon = parseFloat(data.lon);
                        updateAutoAssignment(lat, lon, 'edit-auto-section-display');
                    });
                    editAddressSuggestions.appendChild(suggestionItem);
                } else {
                    editAddressSuggestions.innerHTML = '<div class="p-2 text-gray-500">Keine passende 76... Adresse gefunden.</div>';
                    updateAutoAssignment(0, 0, 'edit-auto-section-display');
                    editAutoSectionDisplay.textContent = 'Keine Geo-Daten gefunden';
                }
            }, 300);
        });
        
        // --- Global click listener to hide suggestion boxes ---
        document.addEventListener('click', (e) => {
            if (suggestionsContainer && !suggestionsContainer.contains(e.target) && e.target !== addressInput) {
                suggestionsContainer.classList.add('hidden');
            }
            if (keywordSuggestionsContainer && !keywordSuggestionsContainer.contains(e.target) && e.target !== keywordInput) {
                keywordSuggestionsContainer.classList.add('hidden');
            }
            
            // NEW: For edit modal
            if (editAddressSuggestions && !editAddressSuggestions.contains(e.target) && e.target !== editAddressInput) {
                editAddressSuggestions.classList.add('hidden');
            }
            if (editKeywordSuggestions && !editKeywordSuggestions.contains(e.target) && e.target !== editKeywordInput) {
                editKeywordSuggestions.classList.add('hidden');
            }
        });


        /**
         * NEW: Generic Keyword Autocomplete Renderer
         * @param {string} query - The search term.
         * @param {HTMLElement} container - The suggestions container element.
         * @param {HTMLInputElement} inputElement - The input field to update on click.
         * @param {function} [onClickCallback] - Optional callback after selection.
         */
        function renderKeywordAutocomplete(query, container, inputElement, onClickCallback) {
            container.innerHTML = '';
            if (query.length < 2) {
                container.classList.add('hidden');
                return;
            }

            const fragment = document.createDocumentFragment();
            let hasMatches = false;

            for (const category in AAO_KEYWORD_CATEGORIES) {
                const keywords = AAO_KEYWORD_CATEGORIES[category];
                const categoryMatchesQuery = category.toLowerCase().includes(query);
                
                let matchesInThisCategory = [];

                if (categoryMatchesQuery) {
                    matchesInThisCategory = keywords;
                } else {
                    matchesInThisCategory = keywords.filter(keyword => 
                        keyword.toLowerCase().includes(query)
                    );
                }

                if (matchesInThisCategory.length > 0) {
                    hasMatches = true;

                    const colors = getCategoryColors(category);
                    const categoryHeader = document.createElement('div');
                    categoryHeader.textContent = category;
                    categoryHeader.className = `p-2 mt-1 font-bold text-xs uppercase border-t ${colors.header}`;
                    fragment.appendChild(categoryHeader);

                    matchesInThisCategory.forEach(keyword => {
                        const suggestionItem = document.createElement('div');
                        suggestionItem.textContent = keyword;
                        suggestionItem.className = `p-2 cursor-pointer ${colors.hover} transition duration-100 text-sm text-gray-800 border-b border-gray-100 last:border-b-0 pl-4`;
                        
                        suggestionItem.addEventListener('click', () => {
                            inputElement.value = keyword;
                            container.classList.add('hidden');
                            container.innerHTML = '';
                            inputElement.focus(); 
                            if (onClickCallback) onClickCallback();
                        });
                        fragment.appendChild(suggestionItem);
                    });
                }
            }

            if (hasMatches) {
                container.appendChild(fragment);
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }
        
        // --- Keyword Autocomplete (Creation Modal) ---
        keywordInput.addEventListener('input', () => {
            validateIncidentForm(); // Validate on input
            const query = keywordInput.value.trim().toLowerCase();
            renderKeywordAutocomplete(query, keywordSuggestionsContainer, keywordInput, validateIncidentForm);
        });
        
        // --- NEW: Keyword Autocomplete (Edit Modal) ---
        editKeywordInput.addEventListener('input', () => {
            const query = editKeywordInput.value.trim().toLowerCase();
            renderKeywordAutocomplete(query, editKeywordSuggestions, editKeywordInput);
        });


        // --- NEW: Event Listeners for Incident Add Mode (UPDATED for Modal) ---
        addIncidentMapBtn.addEventListener('click', () => {
            setIncidentAddMode(true);
            incidentCreationModal.classList.add('hidden'); // CLOSE MODAL
        });

        cancelAddIncidentBtn.addEventListener('click', () => {
            setIncidentAddMode(false);
            incidentCreationModal.classList.remove('hidden'); // RE-OPEN MODAL
        });
        
        // --- NEW: Event Listeners for Incident Edit Mode ---
        editIncidentMapBtn.addEventListener('click', () => {
            setIncidentEditMode(true);
            incidentEditModal.classList.add('hidden'); // CLOSE MODAL
        });
        
        cancelEditIncidentBtn.addEventListener('click', () => {
            setIncidentEditMode(false);
            incidentEditModal.classList.remove('hidden'); // RE-OPEN MODAL
        });
        
        // --- NEW: Listeners for Incident Creation Modal ---
        openCreateIncidentModalBtn.addEventListener('click', () => {
            selectedIncidentId = null; // NEW: Collapse incident
            renderAllIncidents(); // NEW: Update UI
            
            // Reset form
            dispatchForm.reset();
            latInput.value = '';
            lonInput.value = '';
            suggestionsContainer.classList.add('hidden');
            keywordSuggestionsContainer.classList.add('hidden');
            updateAutoAssignment(0, 0, 'auto-section-display');
            autoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
            autoSectionDisplay.classList.add('text-gray-700');
            autoSectionDisplay.classList.remove('text-red-700', 'text-indigo-700');
            
            // Show modal and set initial validation state
            incidentCreationModal.classList.remove('hidden');
            validateIncidentForm(); 
        });
        
        closeIncidentModalBtn.addEventListener('click', () => {
            if (isIncidentAddMode) {
                setIncidentAddMode(false); // Cancel add mode if modal is closed
            }
            incidentCreationModal.classList.add('hidden');
        });
        
        // FIX: Add click-off-to-close listener
        incidentCreationModal.addEventListener('click', (e) => {
            if (e.target === incidentCreationModal) {
                if (isIncidentAddMode) {
                    setIncidentAddMode(false); 
                }
                incidentCreationModal.classList.add('hidden');
            }
        });
        
        // --- NEW: Listeners for Incident Edit Modal ---
        closeIncidentEditModalBtn.addEventListener('click', () => {
            if (isIncidentEditMode) {
                setIncidentEditMode(false); // Cancel edit mode if modal is closed
            }
            incidentEditModal.classList.add('hidden');
            editingIncidentId = null;
        });
        
        // FIX: Add click-off-to-close listener
        incidentEditModal.addEventListener('click', (e) => {
            if (e.target === incidentEditModal) {
                if (isIncidentEditMode) {
                    setIncidentEditMode(false); 
                }
                incidentEditModal.classList.add('hidden');
                editingIncidentId = null;
            }
        });

        // FIX: Helper function for edit modal status buttons
        function setEditStatusButtonState(selectedStatus) {
            const buttons = document.querySelectorAll('.edit-status-btn');
            const hiddenInput = document.getElementById('edit-status-hidden');
            if (hiddenInput) hiddenInput.value = selectedStatus;

            buttons.forEach(btn => {
                const status = btn.dataset.status;
                btn.disabled = false;
                // Reset styles
                btn.classList.remove('bg-red-600', 'bg-blue-600', 'bg-amber-500', 'text-white', 'opacity-75', 'cursor-not-allowed');
                btn.classList.add('bg-white', 'text-gray-700', 'hover:bg-gray-50');

                if (status === selectedStatus) {
                    btn.disabled = true;
                    btn.classList.remove('bg-white', 'text-gray-700', 'hover:bg-gray-50');
                    btn.classList.add('text-white', 'opacity-75', 'cursor-not-allowed');
                    // Apply specific color
                    if (status === 'open') btn.classList.add('bg-red-600');
                    else if (status === 'dispatched') btn.classList.add('bg-blue-600');
                    else if (status === 'completed') btn.classList.add('bg-amber-500');
                }
            });
        }

        // FIX: Add click listener for the status button group
        incidentEditForm.addEventListener('click', (e) => {
            const target = e.target.closest('.edit-status-btn');
            if (target) {
                const status = target.dataset.status;
                setEditStatusButtonState(status);
            }
        });
        
        // Save Changes
        incidentEditForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!editingIncidentId) return;

            const incident = incidents.get(editingIncidentId);
            if (!incident) return;
            
            saveIncidentBtn.disabled = true;
            saveIncidentBtn.textContent = 'Speichere...';

            const newKeyword = editKeywordInput.value.trim();
            const newAddress = editAddressInput.value.trim();
            // FIX: Read from hidden input instead of select
            const newStatus = document.getElementById('edit-status-hidden').value;
            let newLat = parseFloat(editLatInput.value);
            let newLon = parseFloat(editLonInput.value);
            
            if (!newKeyword || !newAddress) {
                showMessage("Stichwort und Adresse dürfen nicht leer sein.", true);
                saveIncidentBtn.disabled = false;
                saveIncidentBtn.textContent = 'Änderungen speichern';
                return;
            }

            // Check if address was changed but not geocoded
            if (isNaN(newLat) || isNaN(newLon)) {
                if (!navigator.onLine) {
                    showMessage("Adresse konnte im Offline-Modus nicht finalisiert werden.", true);
                    saveIncidentBtn.disabled = false;
                    saveIncidentBtn.textContent = 'Änderungen speichern';
                    return;
                }
                
                showMessage("Suche Koordinaten für neue Adresse...", false);
                const fallbackLocation = await geocodeAddress(newAddress);
                
                if (!fallbackLocation || !fallbackLocation.lat || !fallbackLocation.lon) {
                    showMessage("Kartenkoordinaten konnten nicht gefunden werden. Bitte klicken Sie auf den Adressvorschlag oder auf die Karte.", true);
                    saveIncidentBtn.disabled = false;
                    saveIncidentBtn.textContent = 'Änderungen speichern';
                    return;
                }
                
                newLat = parseFloat(fallbackLocation.lat);
                newLon = parseFloat(fallbackLocation.lon);
            }
            
            // Update incident
            incident.keyword = newKeyword;
            incident.formattedAddress = newAddress;
            incident.lat = newLat;
            incident.lon = newLon;
            
            // Handle status change
            if (incident.status !== newStatus) {
                // Do not add to undo history, as this is an explicit edit
                incident.status = newStatus;
            }

            // Re-evaluate EA based on new location/status
            if (incident.status === 'completed') {
                incident.sectionId = null; // Completed incidents have no EA
            } else {
                incident.sectionId = findContainingSection(newLat, newLon);
            }
            
            incidents.set(editingIncidentId, incident);
            saveState();
            
            // Reset UI
            saveIncidentBtn.disabled = false;
            saveIncidentBtn.textContent = 'Änderungen speichern';
            incidentEditModal.classList.add('hidden');
            editingIncidentId = null;
            selectedIncidentId = null; // Deselect
            
            renderAll();
            showMessage("Einsatz erfolgreich aktualisiert.", false);
        });
        
        // Delete Incident
        deleteIncidentBtn.addEventListener('click', () => {
            if (!editingIncidentId) return;
            
            const incident = incidents.get(editingIncidentId);
            if (!incident) return;
            
            const toastMessage = `SIND SIE SICHER, dass Sie "${incident.keyword}" löschen möchten? Diese Aktion kann nicht rückgängig gemacht werden.
                <button id="confirm-delete-incident-${incident.id}" class="mt-2 bg-red-700 text-white px-3 py-1 rounded text-xs font-bold w-full hover:bg-red-800">JA, DAUERHAFT LÖSCHEN</button>`;
            
            showMessage(toastMessage, true, 0); // Permanent toast

            setTimeout(() => {
                const confirmBtn = document.getElementById(`confirm-delete-incident-${incident.id}`);
                if (confirmBtn) {
                    confirmBtn.onclick = (e) => {
                        e.stopPropagation();
                        
                        incidents.delete(incident.id);
                        
                        // Clear from history as well
                        statusHistory = statusHistory.filter(h => h.id !== incident.id);
                        
                        saveState();
                        
                        // Close modal and reset state
                        incidentEditModal.classList.add('hidden');
                        editingIncidentId = null;
                        selectedIncidentId = null;
                        
                        renderAll();
                        
                        // Manually close the toast
                        const parentToast = confirmBtn.closest('.toast-notification');
                        if (parentToast) {
                            parentToast.classList.remove('show');
                            parentToast.classList.add('fade-out');
                            parentToast.addEventListener('transitionend', () => {
                                if (parentToast.parentNode) {
                                    parentToast.parentNode.removeChild(parentToast);
                                }
                            }, { once: true });
                        }
                        
                        showMessage("Einsatz gelöscht.", false);
                    };
                }
            }, 100);
        });


        // --- Final Submission Logic (UPDATED for Modal) ---
        dispatchForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const keyword = keywordInput.value.trim();
            const addressText = addressInput.value.trim();
            let incidentLat = parseFloat(latInput.value);
            let incidentLon = parseFloat(lonInput.value);
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Verarbeite...';
            
            if (!keyword || !addressText) {
                // This check is redundant due to validateIncidentForm, but good for safety
                showMessage("Bitte geben Sie sowohl eine Adresse als auch ein Alarmstichwort ein.", true);
                submitBtn.disabled = false; // Re-enable
                submitBtn.textContent = 'Einsatz erstellen';
                validateIncidentForm(); // Re-run validation
                return;
            }
            
            if (isNaN(incidentLat) || isNaN(incidentLon)) {
                if (!navigator.onLine) {
                    showMessage("Adresse konnte im Offline-Modus nicht finalisiert werden.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Einsatz erstellen';
                    validateIncidentForm();
                    return;
                }
                
                showMessage("Suche Koordinaten für Adresse...", false);
                const fallbackLocation = await geocodeAddress(addressText);
                
                if (!fallbackLocation || !fallbackLocation.lat || !fallbackLocation.lon) {
                    showMessage("Kartenkoordinaten konnten nicht gefunden werden. Bitte klicken Sie auf den Adressvorschlag oder auf die Karte.", true);
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Einsatz erstellen';
                    validateIncidentForm();
                    return;
                }
                
                incidentLat = parseFloat(fallbackLocation.lat);
                incidentLon = parseFloat(fallbackLocation.lon);
                
                latInput.value = incidentLat;
                lonInput.value = incidentLon;
            }
            
            try {
                // Final check for section assignment, now that we guarantee lat/lon
                const finalSectionId = findContainingSection(incidentLat, incidentLon);
                
                const newIncident = {
                    id: generateUUID(),
                    formattedAddress: addressText,        
                    keyword: keyword,
                    lat: incidentLat,
                    lon: incidentLon,
                    status: 'open',
                    notes: '', 
                    sectionId: finalSectionId, 
                    createdAt: new Date().toISOString() 
                };
                
                incidents.set(newIncident.id, newIncident);
                saveState();
                
                selectedIncidentId = null; // NEW: Collapse any open card
                renderAll(); 
                
                // Reset form, disable button, and close modal
                dispatchForm.reset();
                latInput.value = '';
                lonInput.value = '';
                suggestionsContainer.classList.add('hidden');
                keywordSuggestionsContainer.classList.add('hidden');
                updateAutoAssignment(0, 0, 'auto-section-display');
                autoSectionDisplay.textContent = 'Wird nach Adresse bestimmt...';
                autoSectionDisplay.classList.add('text-gray-700');
                autoSectionDisplay.classList.remove('text-red-700', 'text-indigo-700');
                
                submitBtn.disabled = true; // Disable after successful submit
                incidentCreationModal.classList.add('hidden'); // Close modal
                
                showMessage("Einsatz erfolgreich erstellt und automatisch zugeordnet.", false);

            } catch (error) {
                console.error("KRITISCHER LAUFZEITFEHLER beim Erstellen des Einsatzes:", error);
                showMessage(`Kritischer Fehler: Details in der Browser-Konsole prüfen: ${error.message}`, true);
            } finally {
                // Ensure button is re-enabled if error occurred, but stays disabled on success
                if (!incidentCreationModal.classList.contains('hidden')) {
                     submitBtn.disabled = false;
                     validateIncidentForm(); // Re-validate
                }
                submitBtn.textContent = 'Einsatz erstellen';
            }
        });
        
        // --- Completed Section Toggle Logic ---
        completedToggleBtn.addEventListener('click', () => {
            isCompletedSectionOpen = !isCompletedSectionOpen;
            if (isCompletedSectionOpen) {
                completedIncidentList.classList.remove('hidden');
            } else {
                completedIncidentList.classList.add('hidden');
            }
            // Update icon
            const icon = completedToggleBtn.querySelector('.font-mono');
            if (icon) icon.textContent = isCompletedSectionOpen ? '▲' : '▼';
        });
        
        // --- NEW: Active Section Toggle Logic ---
        activeToggleBtn.addEventListener('click', () => {
            isActiveSectionOpen = !isActiveSectionOpen;
            if (isActiveSectionOpen) {
                incidentList.classList.remove('hidden');
            } else {
                incidentList.classList.add('hidden');
            }
            // Update icon
            const icon = activeToggleBtn.querySelector('.font-mono');
            if (icon) icon.textContent = isActiveSectionOpen ? '▲' : '▼';
        });


        // --- NEW: End Shift Modal Logic ---

        function showEndShiftModal() {
            selectedIncidentId = null; // NEW: Collapse incident
            renderAllIncidents(); // NEW: Update UI
            
            // Calculate stats
            let openCount = 0;
            let dispatchedCount = 0;
            let completedCount = 0;
            incidents.forEach(inc => {
                if (inc.status === 'open') openCount++;
                else if (inc.status === 'dispatched') dispatchedCount++;
                else if (inc.status === 'completed') completedCount++;
            });
            const totalCount = incidents.size;
            const eaCount = sections.size;
            const date = new Date().toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' });

            // Populate modal
            reportStatsIncidents.textContent = `${totalCount} (Offen: ${openCount}, Entsandt: ${dispatchedCount}, Abgeschl.: ${completedCount})`;
            reportStatsEas.textContent = `${eaCount}`;
            reportStatsDate.textContent = date;
            
            lagezeichnerInput.value = '';
            
            // Show modal
            endShiftModal.classList.remove('hidden');
        }

        function hideEndShiftModal() {
            endShiftModal.classList.add('hidden');
            lagezeichnerInput.value = '';
        }

        function generateReport(lagezeichner) {
            const reportDate = new Date().toLocaleString('de-DE', { dateStyle: 'full', timeStyle: 'short' });
            const allIncidentsArray = Array.from(incidents.values());
            const allSectionsArray = Array.from(sections.values());
            
            let openCount = 0;
            let dispatchedCount = 0;
            let completedCount = 0;
            
            let incidentsHtml = '';
            allIncidentsArray.forEach(incident => {
                let statusColorClass = '';
                if (incident.status === 'open') {
                    openCount++;
                    statusColorClass = 'bg-red-100 text-red-800 border-red-500';
                } else if (incident.status === 'dispatched') {
                    dispatchedCount++;
                    statusColorClass = 'bg-blue-100 text-blue-800 border-blue-500';
                } else if (incident.status === 'completed') {
                    completedCount++;
                    statusColorClass = 'bg-amber-100 text-amber-800 border-amber-500';
                }
                
                const section = incident.sectionId ? allSectionsArray.find(s => s.id === incident.sectionId) : null;
                const sectionName = section ? `${section.name} (V: ${section.responsible})` : 'Kein EA';
                const sectionColor = section ? (section.color || '#4f46e5') : '#6b7280';
                
                incidentsHtml += `
                    <div class="p-4 bg-white border border-gray-300 rounded-lg shadow-sm ${statusColorClass} border-l-4">
                        <p class="font-bold text-lg text-gray-900">${incident.keyword}</p>
                        <p class="text-sm font-medium text-gray-700">${incident.formattedAddress}</p>
                        <p class="text-sm font-semibold mt-1">Status: ${getGermanStatusText(incident.status)}</p>
                        <p class="text-sm font-semibold mt-1" style="color: ${sectionColor};">EA: ${sectionName}</p>
                        ${incident.notes ? `
                            <div class="mt-2 pt-2 border-t border-gray-200">
                                <p class="text-xs font-bold text-gray-600 mb-1">Notizen:</p>
                                <p class="text-sm text-gray-800 whitespace-pre-wrap">${incident.notes.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            let sectionsHtml = '';
            if (allSectionsArray.length > 0) {
                allSectionsArray.forEach(section => {
                    const sectionColor = section.color || '#4f46e5';
                    sectionsHtml += `
                        <li class="p-2 rounded border-l-4" style="background-color: ${hexToRgba(sectionColor, 0.1)}; border-color: ${sectionColor};">
                            <span class="font-semibold" style="color: ${sectionColor};">${section.name}</span>
                            <span class="text-sm text-gray-700">(V: ${section.responsible})</span>
                        </li>
                    `;
                });
            } else {
                sectionsHtml = '<li class="text-sm text-gray-500">Keine Einsatzabschnitte definiert.</li>';
            }


            // This is the self-contained HTML file content
            // FIX: Reverted to dynamic template literal instead of static content
            const htmlContent = `
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Einsatzprotokoll - ${reportDate}</title>
    <script src="https://cdn.tailwindcss.com"><\/script> 
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"><\/script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @media print {
            .no-print { display: none; }
            #report-map { height: 70vh !important; }
        }
        /* Custom label for EA polygons */
        .ea-label {
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
    </style>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-7xl mx-auto bg-white p-8 rounded-lg shadow-lg">
        
        <!-- Header -->
        <div class="mb-6 pb-4 border-b border-gray-300">
            <h1 class="text-4xl font-bold text-red-700">Einsatzprotokoll</h1>
            <div class="mt-2 text-lg text-gray-700">
                <p><strong>Lagezeichner:</strong> ${lagezeichner.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>
                <p><strong>Berichtsdatum:</strong> ${reportDate}</p>
            </div>
            <button onclick="window.print()" class="no-print mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-150">
                Bericht drucken
            </button>
        </div>

        <!-- Summary -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
            <div class="p-4 bg-gray-50 rounded-lg border">
                <h2 class="text-sm font-bold text-gray-600 uppercase">Einsätze Gesamt</h2>
                <p class="text-3xl font-bold text-gray-900">${incidents.size}</p>
            </div>
            <div class="p-4 bg-gray-50 rounded-lg border">
                <h2 class="text-sm font-bold text-gray-600 uppercase">Details</h2>
                <p class="text-base font-medium text-red-600">Offen: ${openCount}</p>
                <p class="text-base font-medium text-blue-600">Entsandt: ${dispatchedCount}</p>
                <p class="text-base font-medium text-amber-600">Abgeschlossen: ${completedCount}</p>
            </div>
            <div class="p-4 bg-gray-50 rounded-lg border">
                <h2 class="text-sm font-bold text-gray-600 uppercase">Einsatzabschnitte</h2>
                <p class="text-3xl font-bold text-indigo-700">${sections.size}</p>
            </div>
        </div>

        <!-- Map & EA List -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
            <div class="lg:col-span-2">
                <h2 class="text-2xl font-bold text-gray-800 mb-3">Lagekarte</h2>
                <div id="report-map" class="w-full h-[500px] rounded-lg border border-gray-300"></div>
            </div>
            <div>
                <h2 class="text-2xl font-bold text-gray-800 mb-3">Einsatzabschnitte</h2>
                <ul class="space-y-2">
                    ${sectionsHtml}
                </ul>
            </div>
        </div>

        <!-- Incident List -->
        <div>
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Einsatzliste</h2>
            <div class="space-y-4">
                ${incidentsHtml}
            </div>
        </div>

    </div>

    <script>
        // --- Embedded Data ---
        const allIncidents = ${JSON.stringify(allIncidentsArray)};
        const allSections = ${JSON.stringify(allSectionsArray)};

        // --- Helper Functions (Copied from main app) ---
        function getStatusColor(status) {
            if (status === 'open') return 'red';
            if (status === 'dispatched') return 'blue';
            if (status === 'completed') return 'amber'; 
            return 'grey';
        }

        function createMarkerIcon(color) {
            const hexColor = {
                'red': '#ef4444', 
                'blue': '#3b82f6', 
                'amber': '#f59e0b',
                'grey': '#6b7280'
            };
            // FIX: Escaped backticks inside this template literal
            const svgIcon = \`
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="\${hexColor[color]}" width="36px" height="36px">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>\`;
            return L.divIcon({
                html: svgIcon,
                className: '',
                iconSize: [36, 36],
                iconAnchor: [18, 36],
                popupAnchor: [0, -36]
            });
        }
        
        function getGermanStatusText(status) {
            if (status === 'open') return 'OFFEN';
            if (status === 'dispatched') return 'ENTSANDT';
            if (status === 'completed') return 'ABGESCHLOSSEN';
            return 'UNBEKANNT';
        }

        // --- Map Initialization ---
        window.onload = () => {
            const map = L.map('report-map').setView([49.0069, 8.4037], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);

            const featureGroup = L.featureGroup().addTo(map);

            // Add Section Polygons
            allSections.forEach(section => {
                if (section.boundary && section.boundary.length >= 3) {
                    const sectionColor = section.color || '#4f46e5'; // Add fallback
                    const polygon = L.polygon(section.boundary, {
                        color: sectionColor, // Use section color
                        fillColor: sectionColor, // Use section color
                        fillOpacity: 0.2, // CHANGED for consistency
                        weight: 2
                    }).addTo(featureGroup);
                     // FIX: Escaped backticks inside this template literal and variables
                    polygon.bindPopup(\`<b>EA: \${section.name}</b><br>Verantwortlich: \${section.responsible}\`);
                    
                    // NEW: Add permanent label to polygon
                    polygon.bindTooltip(
                        \`<span style="color: \${sectionColor}; font-weight: bold; font-size: 14px; text-shadow: -1px -1px 0 #FFF, 1px -1px 0 #FFF, -1px 1px 0 #FFF, 1px 1px 0 #FFF, 0 0 4px #FFF;">\${section.name}</span>\`, {
                            permanent: true,
                            direction: 'center',
                            className: 'ea-label',
                            interactive: false
                        }
                    );
                    // END NEW
                }
            });

            // Add Incident Markers
            allIncidents.forEach(incident => {
                if (incident.lat && incident.lon) {
                    const color = getStatusColor(incident.status);
                    const icon = createMarkerIcon(color);
                    const statusText = getGermanStatusText(incident.status);
                     // FIX: Escaped backticks inside this template literal and variables
                    const popupContent = \`<b>\${incident.keyword}</b><br>\${incident.formattedAddress}<br>Status: \${statusText}\`;
                    
                    const marker = L.marker([incident.lat, incident.lon], { icon: icon })
                        .addTo(featureGroup)
                        .bindPopup(popupContent);
                }
            });

            // Fit map to show all items
            if (featureGroup.getLayers().length > 0) {
                map.fitBounds(featureGroup.getBounds().pad(0.1));
            }
            
            // --- MAP FIX ---
            // Force map to re-check its size after a brief delay.
            // This is crucial because Tailwind CSS (loaded from CDN)
            // might apply the height (h-[500px]) *after*
            // Leaflet first initializes, causing tiles to not load.
            // The setTimeout ensures this runs after the render tick.
            setTimeout(function() {
                map.invalidateSize();
            }, 100);
            // --- END MAP FIX ---
        };
    <\/script> 
</body>
</html>
            `;
            
            // --- Create and Trigger Download ---
            try {
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                
                const dateString = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
                a.download = `Einsatzprotokoll_${dateString}.html`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                
                hideEndShiftModal();

            } catch (error) {
                console.error("Fehler beim Erstellen des Berichts-Downloads:", error);
                showMessage("Fehler beim Erstellen der Download-Datei.", true);
            }
        }

        endShiftBtn.addEventListener('click', showEndShiftModal);
        cancelReportBtn.addEventListener('click', hideEndShiftModal);
        // FIX: Add click-off-to-close listener
        endShiftModal.addEventListener('click', (e) => {
            if (e.target === endShiftModal) {
                hideEndShiftModal();
            }
        });
        
        createReportBtn.addEventListener('click', () => {
            const lagezeichner = lagezeichnerInput.value.trim();
            if (!lagezeichner) {
                showMessage("Bitte geben Sie einen Namen für den Lagezeichner ein.", true);
                return;
            }
            generateReport(lagezeichner);
        });

        // --- END NEW: End Shift Modal Logic ---


        // --- Initialize on Load ---
        window.onload = () => {
            loadState();
            
            // Set initial toggle states
            if (isActiveSectionOpen) {
                incidentList.classList.remove('hidden');
            } else {
                incidentList.classList.add('hidden');
            }
            
            if (isCompletedSectionOpen) {
                completedIncidentList.classList.remove('hidden');
            } else {
                completedIncidentList.classList.add('hidden');
            }
            
            // Check network status on load
            setOnlineStatus(navigator.onLine);
        };

    </script>
</body>
</html>
