<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spielbrett-Anzeige</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111827; /* gray-900 */
        }
        
        body.grid-center {
            display: grid;
            place-items: center;
            min-height: 100vh;
        }
        
        #game-canvas {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.75);
            border-radius: 0.5rem;
            max-width: 1000px;
            width: 100%;
            aspect-ratio: 16 / 10;
        }
    </style>
</head>

<body class="text-white min-h-screen p-4 font-sans grid-center">

    <main class="w-full max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-6 text-purple-400" style="text-shadow: 0 2px 4px rgba(0,0,0,0.5);">Das Große Rennen</h1>
        
        <canvas id="game-canvas" width="1600" height="1000"></canvas>
        
        <div id="waiting-message" class="text-center text-xl p-10 text-yellow-400">
            <p>Warte auf Spielstart vom Controller...</p>
        </div>
    </main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        // --- Firebase Konfiguration ---
        const firebaseConfig = {
          apiKey: "AIzaSyD0bYsfuu1EipFJ_i-2WAikHQ9ycP1jye0",
          authDomain: "game-8e351.firebaseapp.com",
          projectId: "game-8e351",
          storageBucket: "game-8e351.firebasestorage.app",
          messagingSenderId: "713515393193",
          appId: "1:713515393193:web:534d68c9f0d223f6e149b8",
          measurementId: "G-F21SP6RW0B"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const gameDocRef = doc(db, "publicGames", "mainGameState");

        // --- Canvas Setup ---
        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const waitingMessage = document.getElementById("waiting-message");

        // Globale Speicher für den Pfad und den Status
        let fieldPath = [];
        let currentGameState = null;

        // --- 1. Pfad-Berechnungslogik (ZENTRIERUNGS-KORREKTUR) ---
        function generateFieldPath(totalFields) {
            const path = [];
            const numFields = totalFields + 2; // Start + Felder + Ziel
            
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const padding = 100; // Pixel-Abstand zum Rand

            // Dynamisches Layout
            const assumedAspectRatio = canvasWidth / canvasHeight;
            const fieldsPerColumn = Math.round(Math.sqrt(numFields / assumedAspectRatio));
            const numColumns = Math.ceil(numFields / fieldsPerColumn);
            
            // --- KORREKTUR FÜR ZENTRIERUNG ---
            // Berechne Spalten- und Zeilenabstände basierend auf den "Lücken"
            
            // Vertikaler Abstand
            const vSpacing = (fieldsPerColumn > 1) 
                ? (canvasHeight - 2 * padding) / (fieldsPerColumn - 1) 
                : 0; // Kein Abstand, wenn nur 1 Zeile
            const vOffset = (fieldsPerColumn > 1) ? padding : canvasHeight / 2; // Zentrieren, wenn 1 Zeile

            // Horizontaler Abstand
            const hSpacing = (numColumns > 1) 
                ? (canvasWidth - 2 * padding) / (numColumns - 1) 
                : 0; // Kein Abstand, wenn nur 1 Spalte
            const hOffset = (numColumns > 1) ? padding : canvasWidth / 2; // Zentrieren, wenn 1 Spalte
            
            // --- Ende der Korrektur ---

            for (let i = 0; i < numFields; i++) {
                const col = Math.floor(i / fieldsPerColumn);
                let row = i % fieldsPerColumn;
                
                // Schlangenpfad
                if (col % 2 !== 0 && fieldsPerColumn > 1) { // Nur umkehren, wenn es Zeilen gibt
                    row = (fieldsPerColumn - 1) - row;
                }

                // --- KORRIGIERTE POSITIONSBERECHNUNG ---
                let y;
                if (fieldsPerColumn > 1) {
                    y = (row * vSpacing) + vOffset;
                } else {
                    y = vOffset; // Immer in der Mitte
                }

                let x;
                if (numColumns > 1) {
                    const hBase = (col * hSpacing) + hOffset;
                    // "Zufälliger" Schwung
                    const sway = (fieldsPerColumn > 1) // Nur schwanken, wenn es Zeilen gibt
                                 ? Math.sin(y * 0.05 + col) * (hSpacing * 0.2) 
                                 : 0;
                    x = hBase + sway;
                } else {
                    x = hOffset; // Immer in der Mitte
                }
                // --- Ende der Korrektur ---
                
                let label, type;
                if (i === 0) {
                    label = "Start";
                    type = "start";
                } else if (i === numFields - 1) {
                    label = "Ziel";
                    type = "end";
                } else {
                    label = i.toString();
                    type = "field";
                }
                
                path.push({ x, y, label, type, fieldId: `field-${i === numFields - 1 ? totalFields + 1 : i}` });
            }
            return path;
        }

        // --- 2. Zeichenfunktionen ---
        
        function drawPath(path) {
            if (path.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = "rgba(196, 181, 253, 0.6)"; // purple-300
            ctx.lineWidth = 8;
            ctx.setLineDash([15, 10]);
            ctx.stroke();
            ctx.setLineDash([]); // Zurücksetzen
        }

        function drawFields(path) {
            const radius = 30; // 30px Radius für Felder
            
            ctx.font = "bold 20px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            for (const field of path) {
                ctx.beginPath();
                ctx.arc(field.x, field.y, radius, 0, 2 * Math.PI);
                
                if (field.type === 'start') {
                    ctx.fillStyle = "#22c55e"; // Grün
                } else if (field.type === 'end') {
                    ctx.fillStyle = "#eab308"; // Gelb
                } else if (parseInt(field.label) % 2 === 0) {
                    ctx.fillStyle = "#4b5563"; // gray-600
                } else {
                    ctx.fillStyle = "#374151"; // gray-700
                }
                ctx.fill();
                
                ctx.fillStyle = (field.type === 'end') ? "black" : "white";
                ctx.fillText(field.label, field.x, field.y);
            }
        }

        function drawPlayers(players, path, totalFields) {
            if (!players || !path.length) return;
            const pawnRadius = 15;
            const offsets = [
                {x: -pawnRadius, y: -pawnRadius}, 
                {x: pawnRadius, y: -pawnRadius}, 
                {x: -pawnRadius, y: pawnRadius}, 
                {x: pawnRadius, y: pawnRadius}
            ];

            players.forEach((player, index) => {
                let fieldId;
                if (player.position === 0) fieldId = "field-0";
                else if (player.position > totalFields) fieldId = `field-${totalFields + 1}`;
                else fieldId = `field-${player.position}`;
                
                const field = path.find(p => p.fieldId === fieldId);
                if (!field) return;

                const offset = offsets[index % 4];
                const x = field.x + offset.x;
                const y = field.y + offset.y;

                ctx.beginPath();
                ctx.arc(x, y, pawnRadius, 0, 2 * Math.PI);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = "rgba(0,0,0,0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // --- 3. Haupt-Update-Funktion ---
        function drawFrame(gameState) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState || !gameState.totalFields) {
                canvas.classList.add("hidden");
                waitingMessage.classList.remove("hidden");
                return;
            }
            
            canvas.classList.remove("hidden");
            waitingMessage.classList.add("hidden");

            const newTotalFields = gameState.totalFields || 0;
            const oldTotalFields = (fieldPath.length > 0) ? fieldPath.length - 2 : -1;
            
            if (newTotalFields !== oldTotalFields) {
                console.log("Board: Total fields changed, re-generating path.");
                fieldPath = generateFieldPath(newTotalFields);
            }

            drawPath(fieldPath);
            drawFields(fieldPath);
            drawPlayers(gameState.players, fieldPath, newTotalFields);
        }

        // --- 4. Firebase Listener ---
        async function setupRealtimeListener() {
            try {
                await signInAnonymously(auth);
                console.log("Board: Authenticated successfully.");

                onSnapshot(gameDocRef, (doc) => {
                    console.log("Board: Received data update.");
                    if (doc.exists()) {
                        currentGameState = doc.data();
                        drawFrame(currentGameState);
                    } else {
                        console.log("Board: No game state document.");
                        currentGameState = null;
                        drawFrame(null);
                    }
                });
            } catch (error) {
                console.error("Board: Authentication failed: ", error);
                waitingMessage.textContent = "Fehler bei der Authentifizierung.";
            }
        }
        
        window.addEventListener("resize", () => {
             drawFrame(currentGameState);
        });

        drawFrame(null);
        setupRealtimeListener();
        
    </script>
</body>
</html>
