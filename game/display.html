<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spielbrett-Anzeige</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111827; /* gray-900 */
        }
        
        body.grid-center {
            display: grid;
            place-items: center;
            min-height: 100vh;
        }
        
        #game-canvas {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.75);
            border-radius: 0.5rem;
            max-width: 1000px;
            width: 100%;
            aspect-ratio: 16 / 10;
        }
        
        /* --- KARTEN-MODAL-STYLING (FINALE ANPASSUNG) --- */
        #card-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 10px solid #4b5563; /* gray-600 */
            border-radius: 1rem;
            padding: 0.75rem; /* Reduziert von 1rem */
            width: 280px;
            height: 370px; /* Reduziert von 380px */
            z-index: 100;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Inhalte verteilen */
            align-items: center;
            font-family: 'Times New Roman', Times, serif;
            transition: all 0.3s ease-out;
        }
        #card-modal.hidden {
            display: none;
        }
        .card-corner { /* Wrapper für Ecke oben/unten */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1; /* Abstand zwischen Rang und Farbe reduzieren */
        }
        .card-rank {
            font-size: 3.25rem; /* Reduziert von 4rem */
            font-weight: bold;
        }
        .card-suit {
            font-size: 2.75rem; /* Reduziert von 3.5rem */
        }
        .suit-red { color: #ef4444; } /* red-500 */
        .suit-black { color: #000000; }
        
    </style>
</head>

<body class="text-white min-h-screen p-4 font-sans grid-center">

    <main class="w-full max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-6 text-purple-400" style="text-shadow: 0 2px 4px rgba(0,0,0,0.5);">Das Große Rennen</h1>
        
        <canvas id="game-canvas" width="1600" height="1000"></canvas>
        
        <div id="waiting-message" class="text-center text-xl p-10 text-yellow-400">
            <p>Warte auf Spielstart vom Controller...</p>
        </div>
    </main>
    
    <div id="card-modal" class="hidden">
        
        <!-- Obere Ecke -->
        <div class="self-start card-corner"> 
            <div id="card-rank-top" class="card-rank">A</div>
            <div id="card-suit-top" class="card-suit">♠</div>
        </div>
        
        <!-- Mittleres Symbol -->
        <div id="card-suit-mid" class="card-suit" style="font-size: 5rem;">♠</div> <!-- Reduziert von 6rem -->

        <!-- Untere Ecke -->
        <div class="self-end card-corner" style="transform: rotate(180deg);">
             <div id="card-rank-bottom" class="card-rank">A</div>
             <div id="card-suit-bottom" class="card-suit">♠</div>
        </div>
    </div>
    
    <script type="module">
        // --- DAS GESAMTE JAVASCRIPT IST IDENTISCH ZU VORHER ---
        // --- Es werden keine logischen Änderungen benötigt ---

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        const firebaseConfig = {
          apiKey: "AIzaSyD0bYsfuu1EipFJ_i-2WAikHQ9ycP1jye0",
          authDomain: "game-8e351.firebaseapp.com",
          projectId: "game-8e351",
          storageBucket: "game-8e351.firebasestorage.app",
          messagingSenderId: "713515393193",
          appId: "1:713515393193:web:534d68c9f0d223f6e149b8",
          measurementId: "G-F21SP6RW0B"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const gameDocRef = doc(db, "publicGames", "mainGameState");

        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const waitingMessage = document.getElementById("waiting-message");

        const cardModal = document.getElementById("card-modal");
        const cardRankTop = document.getElementById("card-rank-top");
        const cardSuitTop = document.getElementById("card-suit-top");
        const cardSuitMid = document.getElementById("card-suit-mid");
        const cardRankBottom = document.getElementById("card-rank-bottom");
        const cardSuitBottom = document.getElementById("card-suit-bottom");

        const SKAT_DECK = (function() {
            const ranks = ['7', '8', '9', '10', 'B', 'D', 'K', 'A'];
            const suits = ['♦', '♥', '♠', '♣'];
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ rank, suit, color: (suit === '♦' || suit === '♥') ? 'suit-red' : 'suit-black' });
                }
            }
            return deck;
        })();

        function getCardForField(fieldNumber, totalFields) {
            if (fieldNumber <= 0 || fieldNumber > totalFields) {
                return null;
            }

            if (totalFields < 32) {
                const numCardsToSkip = 32 - totalFields;
                const gameDeck = SKAT_DECK.slice(numCardsToSkip);
                return gameDeck[fieldNumber - 1];
            }
            
            const cardIndex = (fieldNumber - 1) % 32;
            return SKAT_DECK[cardIndex];
        }

        let fieldPath = [];
        let currentGameState = null;
        let lastShowRequestTimestamp = 0;
        let modalHideTimer = null;

        function generateFieldPath(totalFields) {
            const path = [];
            const numFields = totalFields + 2;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const padding = 100;

            const assumedAspectRatio = canvasWidth / canvasHeight;
            const fieldsPerColumn = Math.round(Math.sqrt(numFields / assumedAspectRatio));
            const numColumns = Math.ceil(numFields / fieldsPerColumn);
            
            const vSpacing = (fieldsPerColumn > 1) 
                ? (canvasHeight - 2 * padding) / (fieldsPerColumn - 1) 
                : 0;
            const vOffset = (fieldsPerColumn > 1) ? padding : canvasHeight / 2;

            const hSpacing = (numColumns > 1) 
                ? (canvasWidth - 2 * padding) / (numColumns - 1) 
                : 0;
            const hOffset = (numColumns > 1) ? padding : canvasWidth / 2;
            
            for (let i = 0; i < numFields; i++) {
                const col = Math.floor(i / fieldsPerColumn);
                let row = i % fieldsPerColumn;
                
                if (col % 2 !== 0 && fieldsPerColumn > 1) {
                    row = (fieldsPerColumn - 1) - row;
                }

                let y = (fieldsPerColumn > 1) ? (row * vSpacing) + vOffset : vOffset;
                let x = (numColumns > 1) ? (col * hSpacing) + hOffset : hOffset;

                if (numColumns > 1) {
                    const sway = (fieldsPerColumn > 1) 
                                 ? Math.sin(y * 0.05 + col) * (hSpacing * 0.2) 
                                 : 0;
                    x += sway;
                }
                
                let label, type;
                if (i === 0) {
                    label = "Start";
                    type = "start";
                } else if (i === numFields - 1) {
                    label = "Ziel";
                    type = "end";
                } else {
                    label = i.toString();
                    type = "field";
                }
                
                path.push({ x, y, label, type, fieldId: `field-${i === numFields - 1 ? totalFields + 1 : i}` });
            }
            return path;
        }

        function drawPath(path) {
            if (path.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = "rgba(196, 181, 253, 0.6)";
            ctx.lineWidth = 8;
            ctx.setLineDash([15, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawFields(path) {
            const radius = 30;
            ctx.font = "bold 20px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            for (const field of path) {
                ctx.beginPath();
                ctx.arc(field.x, field.y, radius, 0, 2 * Math.PI);
                if (field.type === 'start') ctx.fillStyle = "#22c55e";
                else if (field.type === 'end') ctx.fillStyle = "#eab308";
                else if (parseInt(field.label) % 2 === 0) ctx.fillStyle = "#4b5563";
                else ctx.fillStyle = "#374151";
                ctx.fill();
                ctx.fillStyle = (field.type === 'end') ? "black" : "white";
                ctx.fillText(field.label, field.x, field.y);
            }
        }

        function drawPlayers(players, path, totalFields) {
            if (!players || !path.length) return;
            const pawnRadius = 15;
            const offsets = [{x: -pawnRadius, y: -pawnRadius}, {x: pawnRadius, y: -pawnRadius}, {x: -pawnRadius, y: pawnRadius}, {x: pawnRadius, y: pawnRadius}];
            players.forEach((player, index) => {
                let fieldId;
                if (player.position === 0) fieldId = "field-0";
                else if (player.position > totalFields) fieldId = `field-${totalFields + 1}`;
                else fieldId = `field-${player.position}`;
                
                const field = path.find(p => p.fieldId === fieldId);
                if (!field) return;
                const offset = offsets[index % 4];
                const x = field.x + offset.x;
                const y = field.y + offset.y;
                ctx.beginPath();
                ctx.arc(x, y, pawnRadius, 0, 2 * Math.PI);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = "rgba(0,0,0,0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function drawFrame(gameState) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState || !gameState.totalFields) {
                canvas.classList.add("hidden");
                waitingMessage.classList.remove("hidden");
                return;
            }
            
            canvas.classList.remove("hidden");
            waitingMessage.classList.add("hidden");

            const newTotalFields = gameState.totalFields || 0;
            const oldTotalFields = (fieldPath.length > 0) ? fieldPath.length - 2 : -1;
            
            if (newTotalFields !== oldTotalFields) {
                console.log("Board: Total fields changed, re-generating path.");
                fieldPath = generateFieldPath(newTotalFields);
            }

            drawPath(fieldPath);
            drawFields(fieldPath);
            drawPlayers(gameState.players, fieldPath, newTotalFields);
        }

        async function setupRealtimeListener() {
            try {
                await signInAnonymously(auth);
                console.log("Board: Authenticated successfully.");

                onSnapshot(gameDocRef, (doc) => {
                    console.log("Board: Received data update.");
                    if (doc.exists()) {
                        currentGameState = doc.data();
                        drawFrame(currentGameState);
                        handleCardReveal(currentGameState);
                    } else {
                        console.log("Board: No game state document.");
                        currentGameState = null;
                        drawFrame(null);
                    }
                });
            } catch (error) {
                console.error("Board: Authentication failed: ", error);
                waitingMessage.textContent = "Fehler bei der Authentifizierung.";
            }
        }
        
        function handleCardReveal(gameState) {
            const request = gameState.showCardForPlayer;
            
            if (request && request.timestamp > lastShowRequestTimestamp) {
                console.log("Board: New card reveal request detected.");
                lastShowRequestTimestamp = request.timestamp;
                
                const player = gameState.players.find(p => p.id === request.id);
                if (!player) return;

                const card = getCardForField(player.position, gameState.totalFields);
                
                if (modalHideTimer) clearTimeout(modalHideTimer);

                if (card) {
                    const colorClass = card.color;
                    [cardRankTop, cardRankBottom, cardSuitTop, cardSuitBottom, cardSuitMid].forEach(el => {
                        el.classList.remove('suit-red', 'suit-black');
                        el.classList.add(colorClass);
                    });
                    
                    cardRankTop.textContent = card.rank;
                    cardRankBottom.textContent = card.rank;
                    cardSuitTop.textContent = card.suit;
                    cardSuitBottom.textContent = card.suit;
                    cardSuitMid.textContent = card.suit;
                    
                } else {
                    [cardRankTop, cardRankBottom, cardSuitTop, cardSuitBottom, cardSuitMid].forEach(el => {
                        el.classList.remove('suit-red');
                        el.classList.add('suit-black');
                    });
                    cardRankTop.textContent = "";
                    cardSuitTop.textContent = "";
                    cardSuitMid.textContent = "Keine Karte";
                    cardRankBottom.textContent = "";
                    cardSuitBottom.textContent = "";
                }
                
                cardModal.classList.remove("hidden");

                modalHideTimer = setTimeout(() => {
                    cardModal.classList.add("hidden");
                }, 3000);
            }
        }

        window.addEventListener("resize", () => {
             drawFrame(currentGameState);
        });

        drawFrame(null);
        setupRealtimeListener();
        
    </script>
</body>
</html>
