<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spielbrett-Anzeige</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #111827; /* gray-900 */
        }
        
        body.grid-center {
            display: grid;
            place-items: center;
            min-height: 100vh;
        }
        
        #game-canvas {
            background-color: #1f2937; /* gray-800 */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.75);
            border-radius: 0.5rem;
            max-width: 1000px;
            width: 100%;
            aspect-ratio: 16 / 10;
        }
        
        /* --- NEUES KARTEN-MODAL-STYLING --- */
        #card-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 10px solid #4b5563; /* gray-600 */
            border-radius: 1rem;
            padding: 2rem;
            width: 300px;
            height: 420px;
            z-index: 100;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-family: 'Times New Roman', Times, serif;
            transition: all 0.3s ease-out;
        }
        #card-modal.hidden {
            display: none;
        }
        .card-rank {
            font-size: 6rem; /* 96px */
            font-weight: bold;
        }
        .card-suit {
            font-size: 5rem; /* 80px */
        }
        .suit-red { color: #ef4444; } /* red-500 */
        .suit-black { color: #000000; }
        
    </style>
</head>

<body class="text-white min-h-screen p-4 font-sans grid-center">

    <main class="w-full max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-6 text-purple-400" style="text-shadow: 0 2px 4px rgba(0,0,0,0.5);">Das Große Rennen</h1>
        
        <canvas id="game-canvas" width="1600" height="1000"></canvas>
        
        <div id="waiting-message" class="text-center text-xl p-10 text-yellow-400">
            <p>Warte auf Spielstart vom Controller...</p>
        </div>
    </main>
    
    <!-- 
      --- NEUES KARTEN-MODAL --- 
      Dies ist das Pop-up-Fenster für die Karte.
    -->
    <div id="card-modal" class="hidden">
        <div class="self-start">
            <div id="card-rank-top" class="card-rank leading-none">A</div>
            <div id="card-suit-top" class="card-suit leading-none">♠</div>
        </div>
        <div id="card-suit-mid" class="card-suit" style="font-size: 8rem;">♠</div>
        <div class="self-end" style="transform: rotate(180deg);">
             <div id="card-rank-bottom" class="card-rank leading-none">A</div>
             <div id="card-suit-bottom" class="card-suit leading-none">♠</div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        // --- Firebase Konfiguration (wie gehabt) ---
        const firebaseConfig = {
          apiKey: "AIzaSyD0bYsfuu1EipFJ_i-2WAikHQ9ycP1jye0",
          authDomain: "game-8e351.firebaseapp.com",
          projectId: "game-8e351",
          storageBucket: "game-8e351.firebasestorage.app",
          messagingSenderId: "713515393193",
          appId: "1:713515393193:web:534d68c9f0d223f6e149b8",
          measurementId: "G-F21SP6RW0B"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const gameDocRef = doc(db, "publicGames", "mainGameState");

        // --- Canvas Setup (wie gehabt) ---
        const canvas = document.getElementById("game-canvas");
        const ctx = canvas.getContext("2d");
        const waitingMessage = document.getElementById("waiting-message");

        // --- NEUES KARTEN-MODAL Setup ---
        const cardModal = document.getElementById("card-modal");
        const cardRankTop = document.getElementById("card-rank-top");
        const cardSuitTop = document.getElementById("card-suit-top");
        const cardSuitMid = document.getElementById("card-suit-mid");
        const cardRankBottom = document.getElementById("card-rank-bottom");
        const cardSuitBottom = document.getElementById("card-suit-bottom");

        // --- NEUE KARTEN-LOGIK ---
        
        // Das volle 32-Karten-Skat-Deck, geordnet vom niedrigsten zum höchsten Wert
        const SKAT_DECK = (function() {
            const ranks = ['7', '8', '9', '10', 'B', 'D', 'K', 'A'];
            const suits = ['♦', '♥', '♠', '♣']; // Karo, Herz, Pik, Kreuz
            const deck = [];
            for (const suit of suits) {
                for (const rank of ranks) {
                    deck.push({ rank, suit, color: (suit === '♦' || suit === '♥') ? 'suit-red' : 'suit-black' });
                }
            }
            return deck; // Ergibt ein 32-Karten-Array
        })();

        // Holt die korrekte Karte für ein Feld, basierend auf der Gesamtzahl der Felder
        function getCardForField(fieldNumber, totalFields) {
            // Start (0) und Ziel (über totalFields) haben keine Karten
            if (fieldNumber <= 0 || fieldNumber > totalFields) {
                return null;
            }

            // Fall 1: Weniger Felder als Karten (z.B. 30 Felder)
            if (totalFields < 32) {
                const numCardsToSkip = 32 - totalFields;
                // Wir überspringen die niedrigsten Karten (z.B. ♦7, ♦8)
                const gameDeck = SKAT_DECK.slice(numCardsToSkip);
                return gameDeck[fieldNumber - 1]; // Feld 1 bekommt Karte 0
            }
            
            // Fall 2: Mehr oder gleich viele Felder als Karten (z.B. 40 Felder)
            // Wir verwenden Modulo, um das Deck zu wiederholen
            const cardIndex = (fieldNumber - 1) % 32;
            return SKAT_DECK[cardIndex];
        }

        // --- Ende der Kartenlogik ---

        let fieldPath = []; // Speichert die (x, y) Koordinaten der Felder
        let currentGameState = null;
        let lastShowRequestTimestamp = 0; // Um doppelte Aufrufe zu verhindern
        let modalHideTimer = null; // Timer zum Ausblenden des Modals

        // --- 1. Pfad-Berechnungslogik (unverändert) ---
        function generateFieldPath(totalFields) {
            // ... (Code aus v9 ist hier, unverändert) ...
            const path = [];
            const numFields = totalFields + 2; 
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const padding = 100; 

            const assumedAspectRatio = canvasWidth / canvasHeight;
            const fieldsPerColumn = Math.round(Math.sqrt(numFields / assumedAspectRatio));
            const numColumns = Math.ceil(numFields / fieldsPerColumn);
            
            const vSpacing = (fieldsPerColumn > 1) ? (canvasHeight - 2 * padding) / (fieldsPerColumn - 1) : 0;
            const vOffset = (fieldsPerColumn > 1) ? padding : canvasHeight / 2;
            const hSpacing = (numColumns > 1) ? (canvasWidth - 2 * padding) / (numColumns - 1) : 0;
            const hOffset = (numColumns > 1) ? padding : canvasWidth / 2;
            
            for (let i = 0; i < numFields; i++) {
                const col = Math.floor(i / fieldsPerColumn);
                let row = i % fieldsPerColumn;
                
                if (col % 2 !== 0 && fieldsPerColumn > 1) {
                    row = (fieldsPerColumn - 1) - row;
                }

                let y = (fieldsPerColumn > 1) ? (row * vSpacing) + vOffset : vOffset;
                let x = (numColumns > 1) ? (col * hSpacing) + hOffset : hOffset;

                if (numColumns > 1) {
                    const sway = (fieldsPerColumn > 1) ? Math.sin(y * 0.05 + col) * (hSpacing * 0.2) : 0;
                    x += sway;
                }
                
                let label, type;
                if (i === 0) {
                    label = "Start";
                    type = "start";
                } else if (i === numFields - 1) {
                    label = "Ziel";
                    type = "end";
                } else {
                    label = i.toString();
                    type = "field";
                }
                path.push({ x, y, label, type, fieldId: `field-${i === numFields - 1 ? totalFields + 1 : i}` });
            }
            return path;
        }

        // --- 2. Zeichenfunktionen (unverändert) ---
        
        function drawPath(path) {
            // ... (Code aus v9) ...
            if (path.length < 2) return;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.strokeStyle = "rgba(196, 181, 253, 0.6)";
            ctx.lineWidth = 8;
            ctx.setLineDash([15, 10]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawFields(path) {
            // ... (Code aus v9) ...
            const radius = 30;
            ctx.font = "bold 20px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            for (const field of path) {
                ctx.beginPath();
                ctx.arc(field.x, field.y, radius, 0, 2 * Math.PI);
                if (field.type === 'start') ctx.fillStyle = "#22c55e";
                else if (field.type === 'end') ctx.fillStyle = "#eab308";
                else if (parseInt(field.label) % 2 === 0) ctx.fillStyle = "#4b5563";
                else ctx.fillStyle = "#374151";
                ctx.fill();
                ctx.fillStyle = (field.type === 'end') ? "black" : "white";
                ctx.fillText(field.label, field.x, field.y);
            }
        }

        function drawPlayers(players, path, totalFields) {
            // ... (Code aus v9) ...
            if (!players || !path.length) return;
            const pawnRadius = 15;
            const offsets = [{x: -pawnRadius, y: -pawnRadius}, {x: pawnRadius, y: -pawnRadius}, {x: -pawnRadius, y: pawnRadius}, {x: pawnRadius, y: pawnRadius}];
            players.forEach((player, index) => {
                let fieldId;
                if (player.position === 0) fieldId = "field-0";
                else if (player.position > totalFields) fieldId = `field-${totalFields + 1}`;
                else fieldId = `field-${player.position}`;
                
                const field = path.find(p => p.fieldId === fieldId);
                if (!field) return;
                const offset = offsets[index % 4];
                const x = field.x + offset.x;
                const y = field.y + offset.y;
                ctx.beginPath();
                ctx.arc(x, y, pawnRadius, 0, 2 * Math.PI);
                ctx.fillStyle = player.color;
                ctx.fill();
                ctx.strokeStyle = "rgba(0,0,0,0.5)";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // --- 3. Haupt-Update-Funktion (unverändert) ---
        function drawFrame(gameState) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState || !gameState.totalFields) {
                canvas.classList.add("hidden");
                waitingMessage.classList.remove("hidden");
                return;
            }
            
            canvas.classList.remove("hidden");
            waitingMessage.classList.add("hidden");

            const newTotalFields = gameState.totalFields || 0;
            const oldTotalFields = (fieldPath.length > 0) ? fieldPath.length - 2 : -1;
            
            if (newTotalFields !== oldTotalFields) {
                console.log("Board: Total fields changed, re-generating path.");
                fieldPath = generateFieldPath(newTotalFields);
            }

            drawPath(fieldPath);
            drawFields(fieldPath);
            drawPlayers(gameState.players, fieldPath, newTotalFields);
        }

        // --- 4. Firebase Listener (MODIFIZIERT) ---
        async function setupRealtimeListener() {
            try {
                await signInAnonymously(auth);
                console.log("Board: Authenticated successfully.");

                onSnapshot(gameDocRef, (doc) => {
                    console.log("Board: Received data update.");
                    if (doc.exists()) {
                        currentGameState = doc.data();
                        drawFrame(currentGameState); // Spiel wie gewohnt neu zeichnen
                        
                        // --- NEUE LOGIK: Auf Karten-Aufdeck-Befehl prüfen ---
                        handleCardReveal(currentGameState);
                        
                    } else {
                        console.log("Board: No game state document.");
                        currentGameState = null;
                        drawFrame(null);
                    }
                });
            } catch (error) {
                console.error("Board: Authentication failed: ", error);
                waitingMessage.textContent = "Fehler bei der Authentifizierung.";
            }
        }
        
        // --- 5. NEUE FUNKTION: Karten-Modal anzeigen/verstecken ---
        function handleCardReveal(gameState) {
            const request = gameState.showCardForPlayer;
            
            // Prüfen, ob eine neue Anfrage vorliegt (basierend auf dem Zeitstempel)
            if (request && request.timestamp > lastShowRequestTimestamp) {
                console.log("Board: New card reveal request detected.");
                lastShowRequestTimestamp = request.timestamp;
                
                // Finde den Spieler und seine Position
                const player = gameState.players.find(p => p.id === request.id);
                if (!player) return;

                const card = getCardForField(player.position, gameState.totalFields);
                
                // Modal-Timer löschen, falls einer läuft
                if (modalHideTimer) clearTimeout(modalHideTimer);

                if (card) {
                    // Karte gefunden -> Modal füllen und anzeigen
                    const colorClass = card.color;
                    [cardRankTop, cardRankBottom, cardSuitTop, cardSuitBottom, cardSuitMid].forEach(el => {
                        el.classList.remove('suit-red', 'suit-black');
                        el.classList.add(colorClass);
                    });
                    
                    cardRankTop.textContent = card.rank;
                    cardRankBottom.textContent = card.rank;
                    cardSuitTop.textContent = card.suit;
                    cardSuitBottom.textContent = card.suit;
                    cardSuitMid.textContent = card.suit;
                    
                } else {
                    // Keine Karte (Start/Ziel) -> Nachricht anzeigen
                    [cardRankTop, cardRankBottom, cardSuitTop, cardSuitBottom, cardSuitMid].forEach(el => {
                        el.classList.remove('suit-red');
                        el.classList.add('suit-black');
                    });
                    cardRankTop.textContent = "";
                    cardSuitTop.textContent = "";
                    cardSuitMid.textContent = "Keine Karte";
                    cardRankBottom.textContent = "";
                    cardSuitBottom.textContent = "";
                }
                
                cardModal.classList.remove("hidden");

                // Modal nach 3 Sekunden automatisch verstecken
                modalHideTimer = setTimeout(() => {
                    cardModal.classList.add("hidden");
                }, 3000);
            }
        }

        window.addEventListener("resize", () => {
             drawFrame(currentGameState);
        });

        drawFrame(null);
        setupRealtimeListener();
        
    </script>
</body>
</html>
