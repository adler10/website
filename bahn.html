<!DOCTYPE html>
<html lang="de" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abfahrtsmonitor</title>
    
    <!-- Turbo: Verbindung zum KVV Server vorab aufbauen -->
    <link rel="preconnect" href="https://projekte.kvv-efa.de">
    <link rel="dns-prefetch" href="https://projekte.kvv-efa.de">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="S-Bahn Monitor">
    <meta name="theme-color" content="#1F2937">

    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Optimierter Spinner: Kleiner und feiner */
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-left-color: #6366F1;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .tab-nav { display: flex; gap: 8px; margin-bottom: 20px; }
        .tab-btn {
            flex-grow: 1; padding: 12px; font-size: 15px; font-weight: 600;
            cursor: pointer; border: 1px solid #374151;
            background-color: #1F2937; color: #9CA3AF;
            border-radius: 8px; transition: all 0.15s ease-out;
            /* Touch-Feedback beschleunigen */
            touch-action: manipulation;
        }
        .tab-btn.active {
            background-color: #4F46E5; color: #FFFFFF; border-color: #4F46E5;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
        }
        /* Nur hovern wenn Maus vorhanden (vermeidet Sticky-Hover auf Mobile) */
        @media (hover: hover) {
            .tab-btn:not(.active):hover { background-color: #374151; color: #F3F4F6; }
        }
        
        /* Sanfte Animation für neue Listenelemente */
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body class="h-full flex items-start justify-center py-6 md:py-16 px-4 bg-gray-900">
    <div class="w-full max-w-md mx-auto"> <!-- max-w-md für besseren Mobile-Look -->
        <h1 class="text-2xl font-bold text-white text-center mb-5 tracking-tight">Pendel-Monitor</h1>

        <!-- Tab Navigation -->
        <nav class="tab-nav" aria-label="Tabs">
            <button id="tab-btn-grenzstrasse" class="tab-btn active" data-target="panel-grenzstrasse">
                Grenzstraße
            </button>
            <button id="tab-btn-europahalle" class="tab-btn" data-target="panel-europahalle">
                Europahalle
            </button>
        </nav>

        <!-- Panel: Grenzstraße -->
        <div id="panel-grenzstrasse" class="tab-panel bg-gray-800 shadow-xl rounded-xl overflow-hidden border border-gray-700">
            <div class="px-4 pt-5 pb-3 flex justify-between items-end">
                <div>
                    <h2 class="text-xl text-indigo-400 font-bold leading-tight">Grenzstraße</h2>
                    <p class="text-xs text-gray-400 mt-1">Richtung Karlsruhe</p>
                </div>
                <div id="status-icon-grenzstrasse" class="hidden"><div class="spinner"></div></div>
            </div>
            <div id="error-message-grenzstrasse" class="hidden px-4 py-3 bg-red-900/30 text-red-300 text-sm mx-4 rounded-lg mb-3"></div>
            <ul id="departures-list-grenzstrasse" role="list" class="divide-y divide-gray-700/50"></ul>
        </div>

        <!-- Panel: Europahalle -->
        <div id="panel-europahalle" class="tab-panel hidden bg-gray-800 shadow-xl rounded-xl overflow-hidden border border-gray-700">
            <div class="px-4 pt-5 pb-3 flex justify-between items-end">
                <div>
                    <h2 class="text-xl text-indigo-400 font-bold leading-tight">Europahalle</h2>
                    <p class="text-xs text-gray-400 mt-1">Richtung Waldstadt</p>
                </div>
                <div id="status-icon-europahalle" class="hidden"><div class="spinner"></div></div>
            </div>
            <div id="error-message-europahalle" class="hidden px-4 py-3 bg-red-900/30 text-red-300 text-sm mx-4 rounded-lg mb-3"></div>
            <ul id="departures-list-europahalle" role="list" class="divide-y divide-gray-700/50"></ul>
        </div>
        
        <footer class="mt-6 text-center">
             <p id="footer-distance-text" class="text-xs text-gray-500 font-medium"></p>
             <p id="data-source-info" class="text-[10px] text-gray-600 mt-1">Daten: KVV/EFA (Live)</p>
        </footer>
    </div>

    <script>
        // --- Konfiguration ---
        const STOPFINDER_URL = "https://projekte.kvv-efa.de/sl3-alone/XSLT_STOPFINDER_REQUEST";
        const DEPARTURE_MONITOR_URL = "https://projekte.kvv-efa.de/sl3-alone/XSLT_DM_REQUEST";
        const REFRESH_INTERVAL_MS = 45000; // Alle 45 Sekunden aktualisieren
        const DATA_CACHE_TTL_MS = 1000 * 120; // Daten für 2 Minuten im Cache halten

        const PACE_CONFIG = {
            BUFFER_TIME_MINUTES: 1,
            PACE_WALK_KMH: 5,
            PACE_JOG_KMH: 10,
            PACE_RUN_KMH: 15,
        };

        const GRENZSTRASSE_COORDS = { latitude: 49.1255, longitude: 8.4116 };
        const EUROPAHALLE_COORDS = { latitude: 49.0028, longitude: 8.3845 };

        // --- Monitore ---
        const monitors = {
            "grenzstrasse": {
                panelId: 'panel-grenzstrasse',
                dom: {
                    list: document.getElementById('departures-list-grenzstrasse'),
                    status: document.getElementById('status-icon-grenzstrasse'),
                    error: document.getElementById('error-message-grenzstrasse'),
                },
                queryName: "Grenzstraße Linkenheim-Hochstetten",
                distance: 600,
                distanceText: "Distanz: ~600m (Am Fuchsheck 2)",
                // Filter: S-Bahn, NICHT Richtung Hochstetten/Linkenheim
                lineFilter: (line) => line.number.startsWith('S'),
                directionFilter: (dir) => {
                    const d = dir.toLowerCase();
                    return !d.includes('hochstetten') && !d.includes('leopoldshafen') && !d.includes('linkenheim');
                },
                lineColor: (line) => (line.number === 'S1' || line.number === 'S11') ? 'bg-green-600' : 'bg-indigo-600',
                stationId: '7001155', // Hardcoded für Speed
                refreshTimer: null,
            },
            "europahalle": {
                panelId: 'panel-europahalle',
                dom: {
                    list: document.getElementById('departures-list-europahalle'),
                    status: document.getElementById('status-icon-europahalle'),
                    error: document.getElementById('error-message-europahalle'),
                },
                queryName: "Europahalle/Europabad, Karlsruhe",
                distance: 450,
                distanceText: "Distanz: ~450m (Carl-Engler-Schule)",
                // Filter: Alle (Trams), Richtung Waldstadt
                lineFilter: (line) => true,
                directionFilter: (dir) => dir.toLowerCase().includes('waldstadt'),
                lineColor: (line) => 'bg-red-600',
                stationId: null, // Wird gelernt
                refreshTimer: null,
            }
        };
        
        let activeMonitorKey = null;
        const footerDistanceText = document.getElementById('footer-distance-text');

        // --- Cache Logic ---
        
        function saveToCache(key, data) {
            try {
                const payload = { timestamp: Date.now(), data: data };
                localStorage.setItem(key, JSON.stringify(payload));
            } catch (e) { console.warn("Cache write fail", e); }
        }

        function loadFromCache(key) {
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return null;
                const payload = JSON.parse(raw);
                // Wenn Cache älter als TTL ist -> null
                if (Date.now() - payload.timestamp > DATA_CACHE_TTL_MS) return null;
                return payload.data;
            } catch (e) { return null; }
        }

        // --- ID Management ---

        // Lädt gespeicherte IDs oder sucht sie (und speichert sie dann)
        async function resolveStationId(monitor) {
            if (monitor.stationId) return monitor.stationId; // Hardcoded

            const cacheKey = `station_id_${monitor.queryName}`;
            const cachedId = localStorage.getItem(cacheKey);
            
            if (cachedId) {
                monitor.stationId = cachedId;
                return cachedId;
            }

            // Wenn nicht im Cache, suchen (langsamer)
            console.log(`Suche ID für ${monitor.queryName}...`);
            const params = new URLSearchParams({ outputFormat: 'JSON', locationServerActive: 1, type_sf: 'stop', name_sf: monitor.queryName });
            try {
                const res = await fetch(`${STOPFINDER_URL}?${params.toString()}`);
                const data = await res.json();
                const point = data.stopFinder?.points?.point;
                if (point) {
                    // KVV API gibt manchmal Array, manchmal Einzelobjekt
                    const p = Array.isArray(point) ? point[0] : point;
                    const id = p.stateless || p.ref.id;
                    if (id) {
                        monitor.stationId = id;
                        localStorage.setItem(cacheKey, id); // Für immer merken
                        return id;
                    }
                }
            } catch(e) { console.error(e); }
            return null;
        }


        // --- Data Fetching ---

        async function updateDepartures(monitor, useCacheOnly = false) {
            const dataCacheKey = `deps_${monitor.stationId}`;
            
            // 1. Zuerst Cache prüfen & rendern (Sofort-Anzeige)
            const cachedData = loadFromCache(dataCacheKey);
            if (cachedData) {
                renderDepartures(monitor, cachedData, true); // true = isCached
                if (useCacheOnly) return; // Wenn wir nur schnell anzeigen wollen
            }

            // UI: Lade-Spinner anzeigen (nur kleiner Indikator oben rechts)
            monitor.dom.status.classList.remove('hidden');
            monitor.dom.error.classList.add('hidden');

            try {
                // 2. ID sicherstellen
                const id = await resolveStationId(monitor);
                if (!id) throw new Error("Haltestelle nicht gefunden");

                // 3. Netzwerk-Request
                const params = new URLSearchParams({ 
                    outputFormat: 'JSON', depType: 'stopEvents', locationServerActive: 1, 
                    mode: 'direct', type_dm: 'stop', useOnlyStops: 1, useRealtime: 1, name_dm: id 
                });
                
                const res = await fetch(`${DEPARTURE_MONITOR_URL}?${params.toString()}`);
                const data = await res.json();
                const list = data.departureList || [];

                // 4. Speichern & Rendern
                saveToCache(dataCacheKey, list);
                renderDepartures(monitor, list, false);

            } catch (error) {
                console.error(error);
                // Nur Fehler anzeigen, wenn wir keine Cachedaten haben
                if (!cachedData) {
                    monitor.dom.error.textContent = "Verbindung fehlgeschlagen.";
                    monitor.dom.error.classList.remove('hidden');
                    monitor.dom.list.innerHTML = '';
                }
            } finally {
                monitor.dom.status.classList.add('hidden');
            }
        }

        // --- Rendering ---

        function renderDepartures(monitor, departures, isCached) {
            if (!departures || departures.length === 0) {
                if (!isCached) monitor.dom.list.innerHTML = `<li class="p-6 text-center text-gray-500 text-sm">Keine aktuellen Abfahrten.</li>`;
                return;
            }

            // Filtern
            const filtered = departures
                .filter(d => d.servingLine && monitor.lineFilter(d.servingLine))
                .filter(d => d.servingLine && monitor.directionFilter(d.servingLine.direction));

            if (filtered.length === 0) {
                if (!isCached) monitor.dom.list.innerHTML = `<li class="p-6 text-center text-gray-500 text-sm">Keine passenden Bahnen gefunden.</li>`;
                return;
            }

            // HTML bauen
            let html = '';
            // Nur die ersten 5 anzeigen
            filtered.slice(0, 5).forEach((dep, index) => {
                const line = dep.servingLine.number;
                const direction = dep.servingLine.direction;
                const lineClass = monitor.lineColor(dep.servingLine);
                
                // Ausfall-Logik
                const isCancelled = dep.state === 'cancelled' || dep.servingLine.state === 'deleted' || dep.realtimeStatus === 'DEPARTURE_CANCELLED';

                // Zeit-Logik
                const scheduledTime = formatTime(dep.dateTime);
                const departureDate = parseDateTime(dep.realDateTime || dep.dateTime);
                const minutes = getMinutesUntil(departureDate);

                // Verspätung
                const isDelayed = !isCancelled && dep.realDateTime && (formatTime(dep.realDateTime) !== formatTime(dep.dateTime));
                let delayBadge = '';
                if (isDelayed) {
                    const sched = parseDateTime(dep.dateTime);
                    if (sched && departureDate) {
                        const diff = Math.round((departureDate - sched) / 60000);
                        if (diff > 0) delayBadge = `<span class="text-red-400 text-xs font-bold ml-1">+${diff}</span>`;
                    }
                }

                // Pace
                let rightSideContent = '';
                if (isCancelled) {
                    rightSideContent = `<div class="text-right"><span class="text-red-500 font-bold text-sm bg-red-900/20 px-2 py-1 rounded">ENTFÄLLT</span></div>`;
                } else {
                    const paceHtml = getPaceHtml(minutes, monitor.distance);
                    const minClass = (minutes !== null && minutes <= 5) ? 'text-green-400' : 'text-white';
                    const minText = minutes === null ? '??' : minutes;
                    
                    rightSideContent = `
                        <div class="text-right flex flex-col justify-center items-end">
                            <div class="text-lg font-bold ${minClass} leading-none">
                                ${minText}<span class="text-xs font-normal text-gray-500 ml-1">Min</span>
                            </div>
                            <div class="text-xs text-gray-500 mt-1">${scheduledTime} ${delayBadge}</div>
                            <div class="mt-1">${paceHtml}</div>
                        </div>
                    `;
                }

                const opacityClass = isCancelled ? 'opacity-50 grayscale' : '';
                
                html += `
                <li class="p-4 flex items-center justify-between ${opacityClass} ${isCached ? 'opacity-80' : 'fade-in'}">
                    <div class="flex items-center gap-3 min-w-0">
                        <div class="w-12 h-8 flex items-center justify-center rounded ${lineClass} text-white font-bold text-sm shadow-sm flex-shrink-0">
                            ${line}
                        </div>
                        <div class="min-w-0">
                            <div class="text-gray-100 font-semibold truncate leading-tight text-sm md:text-base" title="${direction}">${direction}</div>
                        </div>
                    </div>
                    <div class="flex-shrink-0 ml-2">
                        ${rightSideContent}
                    </div>
                </li>`;
            });

            if (isCached) {
                // Kleiner Hinweis, dass es Cachedaten sind
                html += `<li class="px-4 py-1 text-[10px] text-center text-gray-600 bg-gray-800/50">Zeige gespeicherte Daten...</li>`;
            }

            monitor.dom.list.innerHTML = html;
        }

        // --- Helper ---

        function formatTime(t) { if(!t) return ""; try { return `${t.hour.padStart(2,'0')}:${t.minute.padStart(2,'0')}`; } catch(e){ return ""; } }
        function parseDateTime(t) { if(!t) return null; return new Date(t.year, t.month-1, t.day, t.hour, t.minute); }
        function getMinutesUntil(d) { if(!d) return null; return Math.max(0, Math.floor((d - new Date()) / 60000)); }
        
        function getPaceHtml(min, dist) {
            if (min === null) return '';
            const buffer = PACE_CONFIG.BUFFER_TIME_MINUTES;
            const time = min - buffer;
            const km = dist / 1000;
            
            if (time <= 0) return '<span class="text-[10px] font-bold text-red-500 uppercase tracking-wider">Zu Spät</span>';
            
            const kmh = km / (time/60);
            let color = 'text-green-500'; let text = 'Gehen';
            if (kmh > PACE_CONFIG.PACE_WALK_KMH) { color = 'text-yellow-500'; text = 'Laufen'; }
            if (kmh > PACE_CONFIG.PACE_JOG_KMH) { color = 'text-orange-500'; text = 'Rennen'; }
            if (kmh > PACE_CONFIG.PACE_RUN_KMH) { color = 'text-red-500'; text = 'Sprint'; }
            
            return `<span class="text-[10px] font-medium ${color}">${text}</span>`;
        }

        // --- App State Control ---

        function switchTab(key) {
            // Timer stoppen
            Object.values(monitors).forEach(m => { if(m.refreshTimer) clearInterval(m.refreshTimer); });
            
            activeMonitorKey = key;
            const mon = monitors[key];

            // Buttons
            document.querySelectorAll('.tab-btn').forEach(b => {
                if(b.dataset.target === mon.panelId) b.classList.add('active'); else b.classList.remove('active');
            });
            // Panels
            document.querySelectorAll('.tab-panel').forEach(p => {
                if(p.id === mon.panelId) p.classList.remove('hidden'); else p.classList.add('hidden');
            });

            footerDistanceText.textContent = mon.distanceText;

            // Daten laden
            updateDepartures(mon); // Lädt sofort Cache, dann Netz
            
            // Timer neu starten
            mon.refreshTimer = setInterval(() => updateDepartures(mon), REFRESH_INTERVAL_MS);
        }

        // --- Location Smart Logic ---
        
        function haversine(lat1, lon1, lat2, lon2) {
            const R=6371; const dLat=(lat2-lat1)*Math.PI/180; const dLon=(lon2-lon1)*Math.PI/180;
            const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function initApp() {
            // Buttons Setup
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const key = btn.id.includes('grenzstrasse') ? 'grenzstrasse' : 'europahalle';
                    localStorage.setItem('preferred_station', key); // Manuelle Wahl merken
                    switchTab(key);
                });
            });

            // 1. Strategie: Gespeicherte Präferenz
            const pref = localStorage.getItem('preferred_station');
            if (pref && monitors[pref]) {
                switchTab(pref);
            } else {
                switchTab('grenzstrasse'); // Default Fallback sofort starten
            }

            // 2. Strategie: GPS Check im Hintergrund (nur wenn nicht kürzlich manuell überschrieben)
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(pos => {
                    const lat = pos.coords.latitude; const lon = pos.coords.longitude;
                    const d1 = haversine(lat, lon, GRENZSTRASSE_COORDS.latitude, GRENZSTRASSE_COORDS.longitude);
                    const d2 = haversine(lat, lon, EUROPAHALLE_COORDS.latitude, EUROPAHALLE_COORDS.longitude);
                    
                    const smartKey = d1 < d2 ? 'grenzstrasse' : 'europahalle';
                    
                    // Wenn wir auf dem "falschen" Tab sind und die Distanz eindeutig ist (<2km Nähe), umschalten
                    // Wir speichern es auch, damit beim nächsten Reload ohne GPS die letzte bekannte Position gilt
                    if (activeMonitorKey !== smartKey && Math.min(d1, d2) < 2.0) {
                        console.log("Standort erkannt, wechsle Tab zu " + smartKey);
                        localStorage.setItem('preferred_station', smartKey);
                        switchTab(smartKey);
                    }
                }, err => {}, { timeout: 5000 });
            }
        }

        // Start
        initApp();

    </script>
</body>
</html>
